<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarNode: Ship Builder</title>

    <!-- QR Code libraries -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #0a0a1a;
            --panel-color: #1a1a2a;
            --text-color: #ecf0f1;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --highlight-color: #9b59b6;
            --title-healthy: rgba(52, 152, 219, 0.2);
            --title-warning: rgba(243, 156, 18, 0.4);
            --title-danger: rgba(231, 76, 60, 0.4);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: var(--panel-color);
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .resources {
            display: flex;
            gap: 20px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .resource-icon {
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .resource-value {
            font-weight: bold;
        }

        main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 3000px;
            height: 3000px;
            transform-origin: 0 0;
            background-image:
                linear-gradient(to right, rgba(52, 152, 219, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(52, 152, 219, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
        }

        .node {
            position: absolute;
            width: 120px;
            height: 120px;
            background-color: var(--panel-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            padding: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            touch-action: none;
            z-index: 10;
        }

        .node:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .node.selected {
            border: 2px solid var(--highlight-color);
            box-shadow: 0 0 15px var(--highlight-color);
        }

        .node-title {
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--title-healthy);
            border-radius: 4px 4px 0 0;
        }

        .node-title.warning {
            background-color: var(--title-warning);
        }

        .node-title.danger {
            background-color: var(--title-danger);
        }

        .node-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 12px;
            text-align: center;
        }

        .node-power {
            margin-top: 2px;
            color: var(--warning-color);
        }

        .connection {
            position: absolute;
            background-color: var(--secondary-color);
            height: 4px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        .connection-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 12px solid var(--secondary-color);
            transform-origin: 0 0;
            z-index: 5;
            opacity: 0.7;
        }

        .node-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 5px;
        }

        .node-button {
            width: 45px;
            height: 35px;
            background: var(--panel-color);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }

        .connection-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            background: rgba(52, 152, 219, 0.1);
            padding: 3px 6px;
            margin-top: 4px;
            border-radius: 3px;
        }

        .unlink-btn {
            cursor: pointer;
            color: var(--danger-color);
            font-weight: bold;
        }

        .node-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar {
            width: 250px;
            background-color: var(--panel-color);
            padding: 10px;
            overflow-y: auto;
            border-left: 2px solid var(--primary-color);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .sidebar h2 {
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .room-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .room-item {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .room-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }

        .room-title {
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .room-details {
            font-size: 12px;
            margin-top: 5px;
        }

        .universe-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .universe-btn {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .universe-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            margin-bottom: 10px;
        }

        .room-type-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
            padding-top: 5px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .type-btn {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .type-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .info-panel {
            margin-top: 20px;
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 10px;
        }

        .node-details table {
            width: 100%;
            font-size: 12px;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .node-details td {
            padding: 3px 0;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-color);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .control-btn {
            width: 40px;
            height: 40px;
            background-color: rgba(52, 152, 219, 0.2);
            border: 1px solid var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            user-select: none;
        }

        .control-btn:hover {
            background-color: rgba(52, 152, 219, 0.4);
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            header {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            main {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 250px;
                border-left: none;
                border-top: 2px solid var(--primary-color);
            }

            .control-btn:active,
            .node-button:active,
            .room-item:active {
                transform: scale(0.95);
                opacity: 0.8;
            }

            .controls {
                position: fixed;
                /* Change to fixed position */
                bottom: 20px;
                /* Position it at the bottom */
                left: 50%;
                transform: translateX(-50%);
                z-index: 15;
                /* Ensure it's above other content */
            }

            .node {
                width: 100px;
                height: 100px;
            }
        }

        .sidebar-toggle {
            display: none;
            /* Hidden by default on desktop */
            position: fixed;
            /* Fixed position so it stays visible when scrolling */
            top: 70px;
            /* Position below header */
            right: 10px;
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            border: 1px solid var(--text-color);
            border-radius: 50%;
            z-index: 20;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .sidebar-toggle-icon {
            width: 20px;
            height: 20px;
            position: relative;
        }

        .sidebar-toggle-icon::before,
        .sidebar-toggle-icon::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background-color: var(--text-color);
            left: 0;
            transition: transform 0.3s;
        }

        .sidebar-toggle-icon::before {
            top: 8px;
            transform: rotate(45deg);
        }

        .sidebar-toggle-icon::after {
            bottom: 9px;
            transform: rotate(-45deg);
        }

        .sidebar-toggle.collapsed .sidebar-toggle-icon::before {
            transform: rotate(-45deg);
        }

        .sidebar-toggle.collapsed .sidebar-toggle-icon::after {
            transform: rotate(45deg);
        }

        /* Update mobile styles */
        @media (max-width: 768px) {
            .sidebar-toggle {
                display: flex;
                /* Only show on mobile */
            }

            .sidebar {
                position: fixed;
                /* Changed to fixed */
                right: 0;
                top: 0;
                bottom: 0;
                height: 100%;
                /* Full height */
                width: 250px;
                transition: transform 0.3s ease;
                z-index: 15;
            }

            .sidebar.collapsed {
                transform: translateX(100%);
                /* Move off-screen when collapsed */
            }
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            max-height: 80%;
            overflow-y: auto;
            border: 2px solid var(--primary-color);
        }

        .notification-modal {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--panel-color);
            border: 2px solid var(--warning-color);
            border-radius: 10px;
            padding: 15px;
            width: 300px;
            z-index: 101;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transform: translateX(350px);
            transition: transform 0.3s ease-out;
        }

        .notification-modal.show {
            transform: translateX(0);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 18px;
            cursor: pointer;
        }

        .job-panel {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .job-input {
            width: 60px;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            text-align: center;
        }

        .durability-display {
            font-size: 12px;
            margin-top: 3px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 24px;
            cursor: pointer;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .ship-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .ship-name-input {
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            width: 180px;
        }

        .export-options,
        .import-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .import-option {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 15px;
        }

        #qrcode {
            background-color: white;
            padding: 15px;
            display: inline-block;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .ship-controls {
                flex-wrap: wrap;
            }
        }

        .faction-intro {
            margin-bottom: 20px;
            text-align: center;
        }

        .faction-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .faction-option {
            background-color: rgba(52, 152, 219, 0.1);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .faction-option:hover {
            background-color: rgba(52, 152, 219, 0.2);
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .faction-option.selected {
            border-color: var(--highlight-color);
            background-color: rgba(155, 89, 182, 0.2);
            box-shadow: 0 0 15px var(--highlight-color);
        }

        .faction-details {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .faction-image {
            width: 80px;
            height: 80px;
            object-fit: contain;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 5px;
        }

        .faction-info {
            flex: 1;
        }

        .faction-info p {
            margin: 5px 0;
            font-size: 14px;
        }

        .faction-actions {
            text-align: center;
            margin-top: 20px;
        }

        /* Restricted room styles */
        .room-item.restricted {
            opacity: 0.5;
            position: relative;
        }

        .room-item.restricted::after {
            content: 'RESTRICTED';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            background-color: rgba(231, 76, 60, 0.8);
            color: white;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .faction-selection {
                grid-template-columns: 1fr;
            }
        }

        /* Ship Visualization Styles */
        .visualization-container {
            display: flex;
            height: calc(100% - 50px);
            gap: 15px;
            margin-top: 15px;
        }

        .ship-canvas-container {
            flex: 3;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        #ship-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background-image: url('https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/space-bg.jpg');
            background-size: cover;
        }

        .components-panel {
            flex: 1;
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            overflow-y: auto;
        }

        .component-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .category-btn {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .category-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .components-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: calc(100% - 60px);
            overflow-y: auto;
        }

        .ship-component {
            background-color: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 5px;
            cursor: grab;
            text-align: center;
            position: relative;
        }

        .ship-component img {
            max-width: 100%;
            max-height: 80px;
            object-fit: contain;
        }

        .ship-component.placed {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-name {
            font-size: 10px;
            margin-top: 5px;
        }

        .placed-component {
            position: absolute;
            cursor: move;
            z-index: 5;
        }

        .placed-component img {
            max-width: 150px;
            max-height: 150px;
            object-fit: contain;
        }

        .visual-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Animation styles */
        @keyframes flying {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 1000px 0;
            }
        }

        .flying-animation {
            animation: flying 20s linear infinite;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .visualization-container {
                flex-direction: column;
            }

            .components-panel {
                height: 200px;
            }

            .ship-canvas-container {
                height: calc(100% - 200px);
            }

            .components-list {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .component-visual.power-core {
            border-radius: 50%;
            background: radial-gradient(circle at center, #fff 0%, #f1c40f 30%, #f39c12 70%, #e67e22 100%);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
        }

        .component-visual.engines {
            border-radius: 5px;
            background: linear-gradient(to right, #e67e22 70%, #e74c3c 70%);
            position: relative;
            overflow: hidden;
        }

        .component-visual.engines:after {
            content: '';
            position: absolute;
            right: 0;
            top: 20%;
            width: 30%;
            height: 60%;
            background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.7) 0%, rgba(231, 76, 60, 0.5) 70%, rgba(0, 0, 0, 0) 100%);
            animation: engineGlow 2s infinite alternate;
        }

        @keyframes engineGlow {
            0% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .component-visual.trapezoid {
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            background: linear-gradient(to bottom, #3498db 70%, #2980b9 70%);
        }

        .component-visual.diamond {
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            background: radial-gradient(circle at center, #9b59b6 50%, #8e44ad 100%);
        }

        .component-visual.hexagon {
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%);
        }

        .component-visual.rectangle {
            border-radius: 5px;
            background: linear-gradient(to bottom, #95a5a6 0%, #7f8c8d 100%);
            border: 2px solid #bdc3c7;
        }

        /* POWER SYSTEMS */
        /* Basic power core with pulsing effect */
        .component-visual.power-core {
            border-radius: 50%;
            background: radial-gradient(circle at center, #fff 0%, #f1c40f 30%, #f39c12 70%, #e67e22 100%);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            animation: powerPulse 4s infinite alternate;
            position: relative;
        }

        /* Add central detail */
        .component-visual.power-core::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
        }

        @keyframes powerPulse {
            0% {
                box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            }

            50% {
                box-shadow: 0 0 25px rgba(241, 196, 15, 0.9);
            }

            100% {
                box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            }
        }

        /* Advanced Warp Core (federation) */
        .component-visual.warp-core {
            border-radius: 50%;
            background: radial-gradient(circle at center, #fff 0%, #3498db 20%, #2980b9 70%, #1a5276 100%);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
            position: relative;
            animation: warpPulse 3s infinite alternate;
        }

        .component-visual.warp-core::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 10%;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }

        .component-visual.warp-core::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            width: 60%;
            height: 10%;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }

        @keyframes warpPulse {
            0% {
                box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
            }

            100% {
                box-shadow: 0 0 30px rgba(52, 152, 219, 1);
            }
        }

        /* Imperial Reactor (star wars) */
        .component-visual.hypermatter-reactor {
            border-radius: 50%;
            background: radial-gradient(circle at center, #fff 0%, #c0392b 30%, #922b21 70%, #641e16 100%);
            box-shadow: 0 0 15px rgba(192, 57, 43, 0.7);
            position: relative;
        }

        .component-visual.hypermatter-reactor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            height: 70%;
            border: 4px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            box-sizing: border-box;
        }

        .component-visual.hypermatter-reactor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            animation: reactorGlow 2s infinite alternate;
        }

        @keyframes reactorGlow {
            0% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(0.8);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* ENGINE SYSTEMS */
        .component-visual.engines {
            border-radius: 5px;
            background: linear-gradient(to right, #e67e22 70%, #e74c3c 70%);
            position: relative;
            overflow: hidden;
        }

        .component-visual.engines::after {
            content: '';
            position: absolute;
            right: 0;
            top: 20%;
            width: 30%;
            height: 60%;
            background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.7) 0%, rgba(231, 76, 60, 0.5) 70%, rgba(0, 0, 0, 0) 100%);
            animation: engineGlow 2s infinite alternate;
        }

        /* Federation Impulse Engine */
        .component-visual.impulse-engine {
            border-radius: 10px;
            background: linear-gradient(to right, #34495e 70%, #2c3e50 70%);
            position: relative;
            overflow: hidden;
            border: 1px solid #5D6D7E;
        }

        .component-visual.impulse-engine::before {
            content: '';
            position: absolute;
            top: 15%;
            left: 10%;
            width: 50%;
            height: 70%;
            background: linear-gradient(to right, #3498db, #2980b9);
            border-radius: 5px;
        }

        .component-visual.impulse-engine::after {
            content: '';
            position: absolute;
            right: 5%;
            top: 30%;
            width: 25%;
            height: 40%;
            background: radial-gradient(ellipse at center, rgba(52, 152, 219, 1) 0%, rgba(41, 128, 185, 0.7) 60%, rgba(0, 0, 0, 0) 100%);
            border-radius: 50%;
            animation: impulseGlow 1.5s infinite alternate;
        }

        @keyframes impulseGlow {
            0% {
                opacity: 0.7;
                box-shadow: 0 0 5px rgba(52, 152, 219, 0.7);
            }

            100% {
                opacity: 1;
                box-shadow: 0 0 15px rgba(52, 152, 219, 1);
            }
        }

        /* Imperial Ion Engine */
        .component-visual.ion-engine {
            border-radius: 5px;
            background: linear-gradient(to right, #2c3e50 80%, #c0392b 80%);
            position: relative;
            overflow: hidden;
            border: 1px solid #566573;
        }

        .component-visual.ion-engine::before {
            content: '';
            position: absolute;
            top: 15%;
            left: 5%;
            width: 70%;
            height: 70%;
            background: linear-gradient(to right, #34495e, #2c3e50);
            border-radius: 3px;
            border-top: 2px solid #566573;
            border-bottom: 2px solid #566573;
        }

        .component-visual.ion-engine::after {
            content: '';
            position: absolute;
            right: 3%;
            top: 25%;
            width: 15%;
            height: 50%;
            background: radial-gradient(ellipse at center, rgba(231, 76, 60, 1) 0%, rgba(192, 57, 43, 0.7) 60%, rgba(0, 0, 0, 0) 100%);
            animation: ionGlow 1s infinite alternate;
        }

        @keyframes ionGlow {
            0% {
                opacity: 0.7;
                box-shadow: 0 0 5px rgba(231, 76, 60, 0.7);
            }

            100% {
                opacity: 1;
                box-shadow: 0 0 15px rgba(231, 76, 60, 1);
            }
        }

        /* COMMAND SYSTEMS */
        .component-visual.trapezoid {
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            background: linear-gradient(to bottom, #3498db 70%, #2980b9 70%);
            position: relative;
        }

        /* Add window details to command rooms */
        .component-visual.trapezoid::before {
            content: '';
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            height: 20%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* Federation Bridge */
        .component-visual.federation-bridge {
            clip-path: polygon(15% 0%, 85% 0%, 100% 100%, 0% 100%);
            background: linear-gradient(to bottom, #3498db 60%, #2980b9 60%);
            position: relative;
        }

        .component-visual.federation-bridge::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 15%;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
        }

        .component-visual.federation-bridge::after {
            content: '';
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 10%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }

        /* Imperial Bridge */
        .component-visual.imperial-bridge {
            clip-path: polygon(0% 30%, 100% 30%, 85% 100%, 15% 100%);
            background: linear-gradient(to bottom, #34495e 50%, #2c3e50 50%);
            position: relative;
        }

        .component-visual.imperial-bridge::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 15%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .component-visual.imperial-bridge::after {
            content: '';
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 5%;
            background: rgba(192, 57, 43, 0.5);
            box-shadow: 0 0 5px rgba(192, 57, 43, 0.5);
        }

        /* TACTICAL SYSTEMS */
        .component-visual.diamond {
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            background: radial-gradient(circle at center, #9b59b6 50%, #8e44ad 100%);
            position: relative;
        }

        /* Weapons with targeting graphics */
        .component-visual.diamond::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        .component-visual.diamond::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10%;
            height: 10%;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }

        /* Phaser Bank */
        .component-visual.phaser-bank {
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            position: relative;
        }

        .component-visual.phaser-bank::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70%;
            height: 4px;
            background: rgba(255, 255, 255, 0.7);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.8);
            animation: phaserCharge 3s infinite;
        }

        @keyframes phaserCharge {
            0% {
                opacity: 0.3;
                width: 30%;
            }

            50% {
                opacity: 1;
                width: 70%;
            }

            100% {
                opacity: 0.3;
                width: 30%;
            }
        }

        /* Turbolaser Battery */
        .component-visual.turbolaser-battery {
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);
            position: relative;
        }

        .component-visual.turbolaser-battery::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 25%;
            width: 4px;
            height: 50%;
            background: rgba(255, 255, 255, 0.7);
            transform: translateY(-50%);
        }

        .component-visual.turbolaser-battery::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 75%;
            width: 4px;
            height: 50%;
            background: rgba(255, 255, 255, 0.7);
            transform: translateY(-50%);
        }

        /* UTILITY SYSTEMS */
        .component-visual.hexagon {
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%);
        }

        /* Deflector Array */
        .component-visual.deflector-array {
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            position: relative;
        }

        .component-visual.deflector-array::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            height: 50%;
            background: radial-gradient(circle at center, rgba(52, 152, 219, 0.3) 0%, rgba(41, 128, 185, 0.1) 70%, rgba(0, 0, 0, 0) 100%);
            border-radius: 50%;
            animation: deflectorPulse 4s infinite;
        }

        @keyframes deflectorPulse {
            0% {
                width: 50%;
                height: 50%;
                opacity: 0.7;
            }

            50% {
                width: 70%;
                height: 70%;
                opacity: 0.3;
            }

            100% {
                width: 50%;
                height: 50%;
                opacity: 0.7;
            }
        }

        /* Jump Gate Array */
        .component-visual.jump-gate-array {
            clip-path: polygon(50% 0%, 80% 30%, 80% 70%, 50% 100%, 20% 70%, 20% 30%);
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            position: relative;
            overflow: hidden;
        }

        .component-visual.jump-gate-array::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        .component-visual.jump-gate-array::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            background: radial-gradient(circle at center, rgba(155, 89, 182, 0.3) 0%, rgba(142, 68, 173, 0.1) 70%, rgba(0, 0, 0, 0) 100%);
            border-radius: 50%;
            animation: jumpgatePulse 3s infinite alternate;
        }

        @keyframes jumpgatePulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.3;
            }

            100% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.7;
            }
        }

        /* HULL SECTIONS - DIFFERENTIATED */
        .component-visual.rectangle {
            border-radius: 5px;
            background: linear-gradient(to bottom, #95a5a6 0%, #7f8c8d 100%);
            border: 2px solid #bdc3c7;
        }

        /* Primary Hull - Blue tinted with special marker */
        .component-visual.primary-hull {
            border-radius: 5px;
            background: linear-gradient(to bottom, #7fb3d5 0%, #2980b9 100%);
            border: 2px solid #d6eaf8;
            position: relative;
        }

        .component-visual.primary-hull::before {
            content: '1';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
            font-size: 16px;
        }

        /* Secondary Hull - Red tinted with special marker */
        .component-visual.secondary-hull {
            border-radius: 5px;
            background: linear-gradient(to bottom, #ec7063 0%, #c0392b 100%);
            border: 2px solid #f9ebea;
            position: relative;
        }

        .component-visual.secondary-hull::before {
            content: '2';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
            font-size: 16px;
        }

        /* Connecting Hull - Yellow tinted with special marker */
        .component-visual.connecting-hull {
            border-radius: 5px;
            background: linear-gradient(to bottom, #f9e79f 0%, #f39c12 100%);
            border: 2px solid #fef9e7;
            position: relative;
        }

        .component-visual.connecting-hull::before {
            content: 'C';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <header>
        <h1>StarNode: Ship Builder</h1>
        <div class="ship-controls">
            <input type="text" placeholder="Ship Name" id="ship-name" class="ship-name-input" value="Unnamed Ship">
            <button class="btn" id="save-ship-btn">Save Ship</button>
            <button class="btn" id="load-ship-btn">Load Ship</button>
        </div>
        <div class="job-panel">
            <input type="number" min="1" max="30" value="5" class="job-input" id="job-days">
            <button class="btn" id="run-job-btn">Run Jobs</button>
        </div>
        <div class="resources">
            <div class="resource">
                <div class="resource-icon">C</div>
                <div class="resource-value" id="credits">10,000</div>
            </div>
            <div class="resource">
                <div class="resource-icon">P</div>
                <div class="resource-value" id="power-display">0</div>
            </div>
        </div>
    </header>
    <main>
        <div class="game-container">
            <div class="grid-container" id="grid">
                <!-- Nodes will be inserted here by JavaScript -->
            </div>
            <div class="controls">
                <div class="control-btn" id="zoom-out">-</div>
                <div class="control-btn" id="reset-view">⊙</div>
                <div class="control-btn" id="zoom-in">+</div>
                <div class="control-btn" id="delete-mode">🗑️</div>
                <div class="control-btn" id="connect-mode">🔗</div>
                <div class="control-btn" id="diagnostics-btn" title="Diagnostics">📊</div>
                <div class="control-btn" id="repair-btn" title="Repair Ship">🔧</div>
                <div class="control-btn" id="visualize-btn" title="Ship Visualization">🚀</div>
            </div>
        </div>

        <div class="sidebar-toggle" id="sidebar-toggle">
            <div class="sidebar-toggle-icon"></div>
        </div>

        <div class="sidebar">
            <h2>Available Rooms</h2>
            <input type="text" class="search-box" id="search-rooms" placeholder="Search rooms...">
            <div class="universe-filter" id="universe-filter">
                <div class="universe-btn active" data-universe="all">All</div>
                <div class="universe-btn" data-universe="star-trek">Star Trek</div>
                <div class="universe-btn" data-universe="star-wars">Star Wars</div>
                <div class="universe-btn" data-universe="babylon-5">Babylon 5</div>
                <div class="universe-btn" data-universe="dune">Dune</div>
            </div>

            <div class="room-type-filter" id="room-type-filter">
                <div class="type-btn active" data-type="all">All Types</div>
                <div class="type-btn" data-type="power">Power</div>
                <div class="type-btn" data-type="engines">Engines</div>
                <div class="type-btn" data-type="command">Command</div>
                <div class="type-btn" data-type="tactical">Tactical</div>
                <div class="type-btn" data-type="utility">Utility</div>
            </div>

            <div class="room-list" id="room-list">
                <!-- Room items will be inserted here by JavaScript -->
            </div>

            <div class="info-panel node-details" id="node-details">
                <h3>Room Details</h3>
                <p id="no-selection">No room selected</p>
                <div id="selection-details" style="display: none;">
                    <table>
                        <tr>
                            <td>Name:</td>
                            <td id="detail-type"></td>
                        </tr>
                        <tr>
                            <td>Type:</td>
                            <td id="detail-room-type"></td>
                        <tr>
                            <td>Universe:</td>
                            <td id="detail-universe"></td>
                        </tr>
                        <tr>
                            <td>Power Generated:</td>
                            <td id="detail-power-gen"></td>
                        </tr>
                        <tr>
                            <td>Power Required:</td>
                            <td id="detail-power-req"></td>
                        </tr>
                        <tr>
                            <td>Current Power:</td>
                            <td id="detail-current-power"></td>
                        </tr>
                        <tr>
                            <td>Requirements:</td>
                            <td id="detail-requirements"></td>
                        </tr>
                        <tr>
                            <td>Connected To:</td>
                            <td id="detail-connections"></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <!-- Modal for ship status -->
    <div class="modal" id="status-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Ship Status</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="status-content">
                <!-- Status will be inserted here -->
            </div>
            <button class="btn" id="close-status">Close</button>
        </div>
    </div>

    <!-- Notification modal -->
    <div class="notification-modal" id="notification-modal">
        <div class="notification-header">
            <h3 id="notification-title">Alert</h3>
            <button class="notification-close">&times;</button>
        </div>
        <div id="notification-content">
            <!-- Notification content will be inserted here -->
        </div>
    </div>

    <!-- Connection details modal -->
    <div class="modal" id="connections-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Room Connections</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="connections-content">
                <!-- Connections will be inserted here -->
            </div>
            <button class="btn" id="close-connections">Close</button>
        </div>
    </div>

    <!-- Repair confirmation modal -->
    <div class="modal" id="repair-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Repair Ship</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="repair-content">
                <!-- Repair details will be inserted here -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="confirm-repair">Repair</button>
                <button class="btn" id="cancel-repair">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Ship Save/Load modal -->
    <div class="modal" id="save-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Save/Export Ship</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p>Ship Name: <span id="export-ship-name"></span></p>
                <div class="export-options">
                    <button class="btn" id="export-json-btn">Export as JSON</button>
                    <button class="btn" id="export-qr-btn">Export as QR Code</button>
                </div>
                <div id="qr-container" style="display: none; text-align: center; margin-top: 15px;">
                    <div id="qrcode"></div>
                    <button class="btn" id="download-qr-btn" style="margin-top: 10px;">Download QR Image</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ship Import modal -->
    <div class="modal" id="load-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Import Ship</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="import-options">
                    <div class="import-option">
                        <h3>Upload JSON or QR Image</h3>
                        <input type="file" id="import-file" accept=".json,image/*">
                        <button class="btn" id="import-file-btn">Import File</button>
                    </div>
                    <div class="import-option">
                        <h3>Scan QR Code</h3>
                        <button class="btn" id="scan-qr-btn">Scan with Camera</button>
                        <div id="scanner-container" style="display: none; margin-top: 10px;">
                            <video id="scanner-video" style="width: 100%; max-width: 300px;"></video>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Faction Selection Modal -->
    <div class="modal" id="faction-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Choose Your Ship Framework</h2>
            </div>
            <div class="modal-body">
                <p class="faction-intro">Select a faction to determine your starting credits and design constraints:</p>

                <div class="faction-selection">
                    <div class="faction-option" data-faction="federation">
                        <h3>Federation Starship</h3>
                        <div class="faction-details">
                            <img src="https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/federation.png"
                                alt="Federation" class="faction-image">
                            <div class="faction-info">
                                <p><strong>Starting Bonus:</strong> +5,000 credits</p>
                                <p><strong>Design Freedom:</strong> High</p>
                                <p><strong>Description:</strong> Balanced design with varied room options. Federation
                                    ships can accommodate a wide range of technologies and configurations.</p>
                            </div>
                        </div>
                    </div>

                    <div class="faction-option" data-faction="empire">
                        <h3>Imperial Star Destroyer</h3>
                        <div class="faction-details">
                            <img src="https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/empire.png" alt="Empire"
                                class="faction-image">
                            <div class="faction-info">
                                <p><strong>Starting Bonus:</strong> +6,000 credits</p>
                                <p><strong>Design Freedom:</strong> Medium</p>
                                <p><strong>Description:</strong> Powerful but rigid. Imperial ships require more
                                    tactical rooms and power generation, but provide substantial financial backing.</p>
                            </div>
                        </div>
                    </div>

                    <div class="faction-option" data-faction="harkonnen">
                        <h3>House Harkonnen Vessel</h3>
                        <div class="faction-details">
                            <img src="https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/harkonnen.png"
                                alt="Harkonnen" class="faction-image">
                            <div class="faction-info">
                                <p><strong>Starting Bonus:</strong> +8,000 credits</p>
                                <p><strong>Design Freedom:</strong> Low</p>
                                <p><strong>Description:</strong> Wealthy but demanding. Harkonnen ships receive
                                    substantial funding but have strict requirements for command, power, and tactical
                                    systems.</p>
                            </div>
                        </div>
                    </div>

                    <div class="faction-option" data-faction="independent">
                        <h3>Independent Trader</h3>
                        <div class="faction-details">
                            <img src="https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/independent.png"
                                alt="Independent" class="faction-image">
                            <div class="faction-info">
                                <p><strong>Starting Bonus:</strong> +2000 credits</p>
                                <p><strong>Design Freedom:</strong> Very High</p>
                                <p><strong>Description:</strong> Complete design freedom but limited resources.
                                    Independent traders can use any technology but start with minimal funding.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ship Visualization Modal -->
    <div class="modal" id="visual-ship-modal">
        <div class="modal-content" style="width: 90%; max-width: 900px; height: 80%;">
            <div class="modal-header">
                <h2>Ship Visualization</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="visual-controls">
                    <button class="btn" id="auto-arrange-btn">Auto Arrange</button>
                    <button class="btn" id="save-design-btn">Save Design</button>
                </div>
                <div class="visualization-container">
                    <div class="ship-canvas-container">
                        <div id="ship-canvas"></div>
                    </div>
                    <div class="components-panel">
                        <h3>Ship Components</h3>
                        <div class="component-categories">
                            <div class="category-btn active" data-category="all">All</div>
                            <div class="category-btn" data-category="hull">Hull</div>
                            <div class="category-btn" data-category="power">Power</div>
                            <div class="category-btn" data-category="engine">Engines</div>
                            <div class="category-btn" data-category="command">Command</div>
                            <div class="category-btn" data-category="tactical">Tactical</div>
                        </div>
                        <div class="components-list" id="components-list">
                            <!-- Components will be added here dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        const factions = {
            federation: {
                name: "Federation Starship",
                creditBonus: 5000,
                restrictedRooms: [], // No restrictions
                requiredRooms: {
                    power: 1,
                    engines: 1,
                    command: 1
                },
                incomeMultiplier: 1.0
            },
            empire: {
                name: "Imperial Star Destroyer",
                creditBonus: 6000,
                restrictedRooms: ['suspensor-drive', 'holtzman-generator', 'navigation-chamber'], // No Dune tech
                requiredRooms: {
                    power: 2,
                    engines: 1,
                    command: 1,
                    tactical: 2
                },
                incomeMultiplier: 1.2
            },
            harkonnen: {
                name: "House Harkonnen Vessel",
                creditBonus: 8000,
                restrictedRooms: ['warp-core', 'federation-bridge', 'impulse-engine', 'phaser-bank', 'shield-generator'], // No Federation tech
                requiredRooms: {
                    power: 3,
                    engines: 2,
                    command: 2,
                    tactical: 3
                },
                incomeMultiplier: 1.5
            },
            independent: {
                name: "Independent Trader",
                creditBonus: 2000,
                restrictedRooms: [], // No restrictions
                requiredRooms: {
                    power: 1,
                    engines: 1
                },
                incomeMultiplier: 0.8
            }
        };

        // Game state
        const gameState = {
            credits: 10000,
            nodes: [],
            connections: [],
            selectedNode: null,
            draggedNode: null,
            connectMode: false,
            deleteMode: false,
            selectedRoomType: null,
            lastNodeId: 0,
            gridScale: 1,
            gridOffsetX: 0,
            gridOffsetY: 0,
            startPanX: 0,
            startPanY: 0,
            isPanning: false,
            isConnecting: false,
            connectionStartNode: null,
            universeFilter: 'all',
            roomTypeFilter: 'all',
            searchTerm: '',
            lastConnectionId: 0,
            selectedFaction: null,
            factionRequirementsMet: false,
        };

        // Room types database with universe categorization
        const roomTypes = [
            // Star Trek Rooms
            {
                id: 'warp-core',
                name: 'Warp Core',
                universe: 'star-trek',
                type: 'power',
                cost: 1000,
                powerGeneration: 500,
                powerRequirement: 0,
                requirements: [],
                description: 'Federation warp core that generates significant power for all ship systems.'
            },
            {
                id: 'impulse-engine',
                name: 'Impulse Engine',
                universe: 'star-trek',
                type: 'engines',
                cost: 600,
                powerGeneration: 0,
                powerRequirement: 200,
                requirements: ['power'],
                description: 'Sublight propulsion system used for short-range travel.'
            },
            {
                id: 'federation-bridge',
                name: 'Federation Bridge',
                universe: 'star-trek',
                type: 'command',
                cost: 1200,
                powerGeneration: 0,
                powerRequirement: 300,
                requirements: ['power', 'engines'],
                description: 'Command center for the entire vessel.'
            },
            {
                id: 'phaser-bank',
                name: 'Phaser Bank',
                universe: 'star-trek',
                type: 'tactical',
                cost: 800,
                powerGeneration: 0,
                powerRequirement: 250,
                requirements: ['power'],
                description: 'Direct energy weapon system used by Starfleet vessels.'
            },
            {
                id: 'shield-generator',
                name: 'Shield Generator',
                universe: 'star-trek',
                type: 'tactical',
                cost: 700,
                powerGeneration: 0,
                powerRequirement: 200,
                requirements: ['power'],
                description: 'Creates defensive energy shields around the vessel.'
            },
            {
                id: 'matter-antimatter-core',
                name: 'Matter/Antimatter Core',
                universe: 'star-trek',
                type: 'power',
                cost: 1500,
                powerGeneration: 800,
                powerRequirement: 0,
                requirements: [],
                description: 'Advanced Starfleet power source utilizing matter/antimatter reactions. Highly efficient but expensive.'
            },
            {
                id: 'deflector-array',
                name: 'Deflector Array',
                universe: 'star-trek',
                type: 'utility',
                cost: 650,
                powerGeneration: 0,
                powerRequirement: 180,
                requirements: ['power'],
                description: 'Projects deflector fields to clear debris from the ships path and can be reconfigured for various tasks.'
            },


            // Star Wars Rooms
            {
                id: 'hypermatter-reactor',
                name: 'Hypermatter Reactor',
                universe: 'star-wars',
                type: 'power',
                cost: 1200,
                powerGeneration: 600,
                powerRequirement: 0,
                requirements: [],
                description: 'Highly efficient power generator used in Imperial vessels.'
            },
            {
                id: 'ion-engine',
                name: 'Ion Engine',
                universe: 'star-wars',
                type: 'engines',
                cost: 500,
                powerGeneration: 0,
                powerRequirement: 150,
                requirements: ['power'],
                description: 'Sublight propulsion system used in TIE fighters and Star Destroyers.'
            },
            {
                id: 'imperial-bridge',
                name: 'Imperial Bridge',
                universe: 'star-wars',
                type: 'command',
                cost: 1000,
                powerGeneration: 0,
                powerRequirement: 250,
                requirements: ['power', 'engines'],
                description: 'Command center featuring crew pits and elevated walkways.'
            },
            {
                id: 'turbolaser-battery',
                name: 'Turbolaser Battery',
                universe: 'star-wars',
                type: 'tactical',
                cost: 900,
                powerGeneration: 0,
                powerRequirement: 300,
                requirements: ['power'],
                description: 'Heavy weapon system capable of planetary bombardment.'
            },
            {
                id: 'deflector-shield',
                name: 'Deflector Shield',
                universe: 'star-wars',
                type: 'tactical',
                cost: 750,
                powerGeneration: 0,
                powerRequirement: 220,
                requirements: ['power'],
                description: 'Projects energy shields to protect against incoming attacks.'
            },
            {
                id: 'kyber-crystal-matrix',
                name: 'Kyber Crystal Matrix',
                universe: 'star-wars',
                type: 'power',
                cost: 2000,
                powerGeneration: 1000,
                powerRequirement: 0,
                requirements: [],
                description: 'Rare kyber crystal array that generates massive power. Extremely expensive but powerful.'
            },
            {
                id: 'tractor-beam',
                name: 'Tractor Beam',
                universe: 'star-wars',
                type: 'tactical',
                cost: 700,
                powerGeneration: 0,
                powerRequirement: 200,
                requirements: ['power'],
                description: 'Projects gravitational fields to capture or manipulate external objects.'
            },

            // Babylon 5 Rooms
            {
                id: 'fusion-reactor',
                name: 'Fusion Reactor',
                universe: 'babylon-5',
                type: 'power',
                cost: 900,
                powerGeneration: 450,
                powerRequirement: 0,
                requirements: [],
                description: 'Standard Earth Alliance power generation system.'
            },
            {
                id: 'gravimetric-engine',
                name: 'Gravimetric Engine',
                universe: 'babylon-5',
                type: 'engines',
                cost: 650,
                powerGeneration: 0,
                powerRequirement: 180,
                requirements: ['power'],
                description: 'Propulsion system that manipulates gravitational fields.'
            },
            {
                id: 'earthforce-cic',
                name: 'Earthforce CIC',
                universe: 'babylon-5',
                type: 'command',
                cost: 950,
                powerGeneration: 0,
                powerRequirement: 230,
                requirements: ['power', 'engines'],
                description: 'Combat Information Center used in Earth Alliance vessels.'
            },
            {
                id: 'interceptor-grid',
                name: 'Interceptor Grid',
                universe: 'babylon-5',
                type: 'tactical',
                cost: 700,
                powerGeneration: 0,
                powerRequirement: 200,
                requirements: ['power'],
                description: 'Defense system that intercepts incoming projectiles.'
            },
            {
                id: 'quantium-40-generator',
                name: 'Quantium-40 Generator',
                universe: 'babylon-5',
                type: 'power',
                cost: 1400,
                powerGeneration: 750,
                powerRequirement: 0,
                requirements: [],
                description: 'Advanced power system utilizing rare Quantium-40 for enhanced energy generation.'
            },
            {
                id: 'jump-gate-array',
                name: 'Jump Gate Array',
                universe: 'babylon-5',
                type: 'utility',
                cost: 1200,
                powerGeneration: 0,
                powerRequirement: 400,
                requirements: ['power', 'engines'],
                description: 'Creates a stabilized vortex into hyperspace, allowing for interstellar travel.'
            },

            // Dune Rooms
            {
                id: 'holtzman-generator',
                name: 'Holtzman Generator',
                universe: 'dune',
                type: 'power',
                cost: 1500,
                powerGeneration: 700,
                powerRequirement: 0,
                requirements: [],
                description: 'Powerful energy source that can also generate shields.'
            },
            {
                id: 'suspensor-drive',
                name: 'Suspensor Drive',
                universe: 'dune',
                type: 'engines',
                cost: 800,
                powerGeneration: 0,
                powerRequirement: 220,
                requirements: ['power'],
                description: 'Antigravity propulsion system used by Guild Heighliners.'
            },
            {
                id: 'navigation-chamber',
                name: 'Navigation Chamber',
                universe: 'dune',
                type: 'command',
                cost: 1300,
                powerGeneration: 0,
                powerRequirement: 350,
                requirements: ['power', 'engines'],
                description: 'Specialized room for Guild Navigators to fold space.'
            },
            {
                id: 'lasgun-array',
                name: 'Lasgun Array',
                universe: 'dune',
                type: 'tactical',
                cost: 850,
                powerGeneration: 0,
                powerRequirement: 270,
                requirements: ['power'],
                description: 'Energy weapon system (dangerous when used against shields).'
            },
            {
                id: 'spice-reactor',
                name: 'Spice Reactor',
                universe: 'dune',
                type: 'power',
                cost: 2500,
                powerGeneration: 1200,
                powerRequirement: 0,
                requirements: [],
                description: 'Experimental reactor utilizing refined spice for extraordinary power generation. Extremely expensive.'
            },
            {
                id: 'shields-analysis-room',
                name: 'Shields Analysis Room',
                universe: 'dune',
                type: 'utility',
                cost: 600,
                powerGeneration: 0,
                powerRequirement: 150,
                requirements: ['power'],
                description: 'Analyzes attack vectors to optimize shield frequencies against both projectile and energy weapons.'
            },

            // Agnostic rooms - universal for all fandoms
            {
                id: 'junction-node',
                name: 'Junction Node',
                universe: 'star-trek',
                type: 'utility',
                cost: 350,
                powerGeneration: 0,
                powerRequirement: 20, // Small power cost to operate
                requirements: ['power'],
                description: 'Specialized node with 1 input but 3 outputs. Efficiently splits power between multiple systems.'
            },

            // Enhanced Junction (Conduit Room)
            {
                id: 'power-conduit',
                name: 'Power Conduit',
                universe: 'star-trek',
                type: 'utility',
                cost: 700,
                powerGeneration: 0,
                powerRequirement: 50, // Higher cost to operate
                requirements: ['power'],
                description: 'Advanced junction accepting 2 inputs and providing 3 outputs. Combines power sources for efficient distribution.'
            }
        ];

        // Ship component definitions - maps room types to visual components
        const shipComponents = {
            // Power systems
            'warp-core': {
                name: 'Warp Core',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/warp-core.png',
                category: 'power',
                width: 100,
                height: 100,
                universe: 'star-trek'
            },
            'hypermatter-reactor': {
                name: 'Hypermatter Reactor',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/hypermatter.png',
                category: 'power',
                width: 90,
                height: 90,
                universe: 'star-wars'
            },
            'fusion-reactor': {
                name: 'Fusion Reactor',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/fusion-reactor.png',
                category: 'power',
                width: 80,
                height: 80,
                universe: 'babylon-5'
            },
            'holtzman-generator': {
                name: 'Holtzman Generator',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/holtzman.png',
                category: 'power',
                width: 120,
                height: 120,
                universe: 'dune'
            },

            // Engine systems
            'impulse-engine': {
                name: 'Impulse Engines',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/impulse.png',
                category: 'engine',
                width: 140,
                height: 70,
                universe: 'star-trek'
            },
            'ion-engine': {
                name: 'Ion Engines',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/ion-engine.png',
                category: 'engine',
                width: 130,
                height: 60,
                universe: 'star-wars'
            },
            'gravimetric-engine': {
                name: 'Gravimetric Engine',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/gravimetric.png',
                category: 'engine',
                width: 110,
                height: 80,
                universe: 'babylon-5'
            },
            'suspensor-drive': {
                name: 'Suspensor Drive',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/suspensor.png',
                category: 'engine',
                width: 130,
                height: 70,
                universe: 'dune'
            },

            // Command systems
            'federation-bridge': {
                name: 'Federation Bridge',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/fed-bridge.png',
                category: 'command',
                width: 150,
                height: 80,
                universe: 'star-trek'
            },
            'imperial-bridge': {
                name: 'Imperial Bridge',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/imp-bridge.png',
                category: 'command',
                width: 160,
                height: 70,
                universe: 'star-wars'
            },
            'earthforce-cic': {
                name: 'Earthforce CIC',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/cic.png',
                category: 'command',
                width: 140,
                height: 90,
                universe: 'babylon-5'
            },
            'navigation-chamber': {
                name: 'Navigation Chamber',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/navigation.png',
                category: 'command',
                width: 130,
                height: 100,
                universe: 'dune'
            },

            // Hull sections - available to all
            'hull-section-1': {
                name: 'Primary Hull',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/hull1.png',
                category: 'hull',
                width: 200,
                height: 100,
                universe: 'all'
            },
            'hull-section-2': {
                name: 'Secondary Hull',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/hull2.png',
                category: 'hull',
                width: 180,
                height: 90,
                universe: 'all'
            },
            'hull-section-3': {
                name: 'Connecting Hull',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/hull3.png',
                category: 'hull',
                width: 160,
                height: 80,
                universe: 'all'
            },

            // Tactical systems
            'phaser-bank': {
                name: 'Phaser Banks',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/phaser.png',
                category: 'tactical',
                width: 80,
                height: 40,
                universe: 'star-trek'
            },
            'turbolaser-battery': {
                name: 'Turbolaser Batteries',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/turbolaser.png',
                category: 'tactical',
                width: 90,
                height: 50,
                universe: 'star-wars'
            },
            'interceptor-grid': {
                name: 'Interceptor Grid',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/interceptor.png',
                category: 'tactical',
                width: 70,
                height: 40,
                universe: 'babylon-5'
            },
            'lasgun-array': {
                name: 'Lasgun Array',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/lasgun.png',
                category: 'tactical',
                width: 85,
                height: 45,
                universe: 'dune'
            },

            // Defensive systems mapped to shield generators
            'shield-generator': {
                name: 'Shield Generator',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/shields.png',
                category: 'tactical',
                width: 100,
                height: 60,
                universe: 'star-trek'
            },
            'deflector-shield': {
                name: 'Deflector Shield',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/deflector.png',
                category: 'tactical',
                width: 110,
                height: 70,
                universe: 'star-wars'
            }
        };

        // Add fallback/generic components for any rooms that don't have specific images
        const genericComponents = {
            'power': {
                name: 'Generic Power Core',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/generic-power.png',
                category: 'power',
                width: 90,
                height: 90,
                universe: 'all'
            },
            'engines': {
                name: 'Generic Engines',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/generic-engine.png',
                category: 'engine',
                width: 120,
                height: 60,
                universe: 'all'
            },
            'command': {
                name: 'Generic Bridge',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/generic-bridge.png',
                category: 'command',
                width: 140,
                height: 80,
                universe: 'all'
            },
            'tactical': {
                name: 'Generic Weapons',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/generic-weapon.png',
                category: 'tactical',
                width: 80,
                height: 40,
                universe: 'all'
            },
            'utility': {
                name: 'Generic Module',
                image: 'https://cdn.jsdelivr.net/gh/ronmurphy/StarNode@main/img/generic-module.png',
                category: 'hull',
                width: 70,
                height: 70,
                universe: 'all'
            }
        };

        // DOM elements
        const gridElement = document.getElementById('grid');
        const creditsDisplay = document.getElementById('credits');
        const powerDisplay = document.getElementById('power-display');
        const roomListElement = document.getElementById('room-list');
        const searchBox = document.getElementById('search-rooms');
        const universeFilter = document.getElementById('universe-filter');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const resetViewBtn = document.getElementById('reset-view');
        const deleteBtn = document.getElementById('delete-mode');
        const connectBtn = document.getElementById('connect-mode');
        const nodeDetails = document.getElementById('node-details');
        const noSelection = document.getElementById('no-selection');
        const selectionDetails = document.getElementById('selection-details');
        const statusModal = document.getElementById('status-modal');
        const closeStatusBtn = document.getElementById('close-status');

        let initialPinchDistance = 0;

        // Initialize the game
        function initGame() {
            window.initializing = true;
            renderRoomList();
            updateCreditsDisplay();
            setupEventListeners();
            centerGridView();

            // Welcome notification
            setTimeout(() => {
                window.initializing = false;
                showNotification('Welcome to StarNode', 'Build your ship by selecting rooms from the right panel and placing them on the grid. Connect rooms to share resources.');
            }, 1000);

            // Show faction selection after a brief delay
            setTimeout(showFactionSelection, 500);
        }

        // Update the credits display
        function updateCreditsDisplay() {
            creditsDisplay.textContent = gameState.credits.toLocaleString();
        }

        // Update the power display
        function updatePowerDisplay() {
            let totalPower = 0;
            let usedPower = 0;

            gameState.nodes.forEach(node => {
                if (node.effectivePowerGeneration > 0) {
                    totalPower += node.effectivePowerGeneration;
                }
                if (node.effectivePowerConsumption > 0) {
                    usedPower += node.effectivePowerConsumption;
                }
            });

            powerDisplay.textContent = `${totalPower - usedPower}/${totalPower}`;
        }

        // Show faction selection modal
        function showFactionSelection() {
            const factionModal = document.getElementById('faction-modal');
            factionModal.style.display = 'flex';

            // Add click event listeners to faction options
            document.querySelectorAll('.faction-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    document.querySelectorAll('.faction-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });

                    // Add selected class to clicked option
                    option.classList.add('selected');

                    // Store selected faction
                    const factionId = option.dataset.faction;

                    // Add continue button if not already there
                    if (!document.getElementById('continue-btn')) {
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'faction-actions';
                        actionsDiv.innerHTML = `<button class="btn" id="continue-btn">Begin Construction</button>`;
                        document.querySelector('#faction-modal .modal-body').appendChild(actionsDiv);

                        // Add event listener to continue button
                        document.getElementById('continue-btn').addEventListener('click', () => {
                            selectFaction(factionId);
                            factionModal.style.display = 'none';
                        });
                    }
                });
            });
        }

        function selectFaction(factionId) {
            // Set selected faction
            gameState.selectedFaction = factionId;
            const faction = factions[factionId];

            // Apply credit bonus
            gameState.credits += faction.creditBonus;
            updateCreditsDisplay();

            // Show notification about faction selection
            showNotification('Faction Selected', `You've chosen a ${faction.name}. Your starting credits have been adjusted to ${gameState.credits}.`);

            // Update room list to show restrictions - no need to call previous function
            renderRoomList();

            // Add faction banner to header
            const header = document.querySelector('header');
            const banner = document.createElement('div');
            banner.className = 'faction-banner';
            banner.innerHTML = `<span>${faction.name}</span>`;
            header.appendChild(banner);

            // Check faction requirements initially
            checkFactionRequirements();
        }

        // Check if faction requirements are met
        function checkFactionRequirements() {
            if (!gameState.selectedFaction) {
                gameState.factionRequirementsMet = true;
                return;
            }

            const faction = factions[gameState.selectedFaction];
            const requirements = faction.requiredRooms;

            // Count rooms by type
            const roomCounts = {
                power: 0,
                engines: 0,
                command: 0,
                tactical: 0,
                utility: 0
            };

            gameState.nodes.forEach(node => {
                const roomType = roomTypes.find(r => r.id === node.type);
                if (roomType && roomType.type) {
                    roomCounts[roomType.type]++;
                }
            });

            // Check if all requirements are met
            let allRequirementsMet = true;
            for (const [type, count] of Object.entries(requirements)) {
                if (roomCounts[type] < count) {
                    allRequirementsMet = false;
                    break;
                }
            }

            // console.log("Room counts:", roomCounts);
            // console.log("Requirements:", requirements);

            gameState.factionRequirementsMet = allRequirementsMet;
        }

        // Render the room list based on filters
        function renderRoomList() {
            roomListElement.innerHTML = '';



            const filteredRooms = roomTypes.filter(room => {
                const matchesUniverse = gameState.universeFilter === 'all' || room.universe === gameState.universeFilter;
                const matchesType = gameState.roomTypeFilter === 'all' || room.type === gameState.roomTypeFilter;
                const matchesSearch = room.name.toLowerCase().includes(gameState.searchTerm.toLowerCase()) ||
                    room.description.toLowerCase().includes(gameState.searchTerm.toLowerCase());
                return matchesUniverse && matchesType && matchesSearch;
            });

            filteredRooms.forEach(room => {
                const roomElement = document.createElement('div');
                roomElement.className = 'room-item';
                roomElement.dataset.roomId = room.id;

                const powerInfo = room.powerGeneration > 0
                    ? `+${room.powerGeneration} Power`
                    : `-${room.powerRequirement} Power`;

                roomElement.innerHTML = `
                    <div class="room-title">
                        <span>${room.name}</span>
                        <span>${room.cost} C</span>
                    </div>
                    <div class="room-details">
                        <div>${powerInfo}</div>
                        <div>${room.description}</div>
                    </div>
                `;

                //     roomElement.addEventListener('click', () => selectRoomType(room));
                //     roomListElement.appendChild(roomElement);
                // });

                // Check if room is restricted by faction
                let isRestricted = false;
                if (gameState.selectedFaction) {
                    const faction = factions[gameState.selectedFaction];
                    isRestricted = faction.restrictedRooms.includes(room.id);

                    if (isRestricted) {
                        roomElement.classList.add('restricted');
                        roomElement.title = `This room is restricted by your faction: ${faction.name}`;
                    }
                }

                // Only add click event if not restricted
                if (!isRestricted) {
                    roomElement.addEventListener('click', () => selectRoomType(room));
                }

                roomListElement.appendChild(roomElement);
            });
        }

        // Select a room type for placement
        function selectRoomType(roomType) {
            if (gameState.credits < roomType.cost) {
                alert('Not enough credits!');
                return;
            }

            gameState.selectedRoomType = roomType;

            // Exit other modes when selecting a room
            gameState.connectMode = false;
            gameState.deleteMode = false;
            connectBtn.style.backgroundColor = '';
            deleteBtn.style.backgroundColor = '';

            document.querySelectorAll('.room-item').forEach(el => {
                el.style.backgroundColor = '';
            });

            const selectedElement = document.querySelector(`.room-item[data-room-id="${roomType.id}"]`);
            if (selectedElement) {
                selectedElement.style.backgroundColor = 'rgba(52, 152, 219, 0.4)';
            }
        }

        // Create a new node on the grid
        function createNode(x, y) {
            if (!gameState.selectedRoomType) return;

            const roomType = gameState.selectedRoomType;

            if (gameState.credits < roomType.cost) {
                showNotification('Warning', 'Not enough credits to build this room!');
                return;
            }

            gameState.credits -= roomType.cost;

            const nodeId = ++gameState.lastNodeId;
            const node = {
                id: nodeId,
                type: roomType.id,
                name: roomType.name,
                universe: roomType.universe,
                x: x,
                y: y,
                powerGeneration: roomType.powerGeneration,
                powerRequirement: roomType.powerRequirement,
                requirements: [...roomType.requirements],
                inputs: [],
                outputs: [],
                effectivePowerGeneration: roomType.powerGeneration,
                effectivePowerConsumption: roomType.powerRequirement,
                powerSatisfied: roomType.powerRequirement === 0,
                durability: 100, // Add durability property, starts at 100%
                connections: [] // Track connection IDs directly in the node
            };

            gameState.nodes.push(node);

            renderNode(node);
            updateCreditsDisplay();
            calculateNodeEfficiency();
            updateNodeVisuals();
            updatePowerDisplay();
        }

        // Render a node element on the grid
        function renderNode(node) {
            const nodeElement = document.createElement('div');
            nodeElement.className = 'node';
            nodeElement.id = `node-${node.id}`;
            nodeElement.style.left = `${node.x}px`;
            nodeElement.style.top = `${node.y}px`;

            // Add a class based on the universe
            nodeElement.classList.add(`universe-${node.universe}`);

            const roomType = roomTypes.find(r => r.id === node.type);

            // Determine title class based on durability
            let titleClass = '';
            if (node.durability <= 30) {
                titleClass = 'danger';
            } else if (node.durability <= 60) {
                titleClass = 'warning';
            }

            nodeElement.innerHTML = `
                <div class="node-title ${titleClass}">${node.name}</div>
                <div class="node-info">
                    ${roomType.powerGeneration > 0 ?
                    `<div>Generating: ${node.effectivePowerGeneration}/${roomType.powerGeneration}</div>` :
                    `<div>Consuming: ${node.effectivePowerConsumption}/${roomType.powerRequirement}</div>`
                }
                    <div class="node-power">${node.powerSatisfied ? '✓' : '⚠️'}</div>
                    <div class="durability-display">Durability: ${Math.floor(node.durability)}%</div>
                </div>
                <div class="node-buttons">
                    <div class="node-button connect-btn" data-node-id="${node.id}" title="Connect">↗</div>
                    <div class="node-button connections-btn" data-node-id="${node.id}" title="Manage Connections">🔗</div>
                    <div class="node-button delete-btn" data-node-id="${node.id}" title="Delete">✕</div>
                </div>
            `;

            gridElement.appendChild(nodeElement);

            // Add event listeners for the node
            nodeElement.addEventListener('mousedown', (e) => handleNodeMouseDown(e, node));
            nodeElement.addEventListener('touchstart', (e) => handleNodeTouchStart(e, node), { passive: false });


            const connectBtn = nodeElement.querySelector('.connect-btn');
            connectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                startConnection(node);
            });
            // Add touch event for mobile
            connectBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startConnection(node);
            }, false);

            const connectionsBtn = nodeElement.querySelector('.connections-btn');
            connectionsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showConnectionsModal(node);
            });
            // Add touch event for mobile
            connectionsBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showConnectionsModal(node);
            }, false);

            const deleteBtn = nodeElement.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteNode(node.id);
            });
            // Add touch event for mobile
            deleteBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                deleteNode(node.id);
            }, false);

        }

        // Delete a node
        function deleteNode(nodeId, showScrapMessage = true) {
            const node = gameState.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Remove connections involving this node
            const connectionsToRemove = gameState.connections.filter(
                conn => conn.fromId === nodeId || conn.toId === nodeId
            );

            connectionsToRemove.forEach(conn => {
                removeConnection(conn.id);
            });

            // Remove the node element from the DOM
            const nodeElement = document.getElementById(`node-${nodeId}`);
            if (nodeElement) {
                nodeElement.remove();
            }

            // Calculate refund based on durability
            let refundPercentage = 0.5; // Default 50% refund

            if (node.durability <= 0 && showScrapMessage) {
                // If durability is 0 or less, only 20% refund
                refundPercentage = 0.2;
                showNotification('Room Scrapped', `${node.name} has been scrapped due to 0% durability. You received ${refundPercentage * 100}% of its value in credits.`);
            }

            const refundAmount = Math.floor(roomTypes.find(r => r.id === node.type).cost * refundPercentage);
            gameState.credits += refundAmount;

            // Remove the node from the game state
            gameState.nodes = gameState.nodes.filter(n => n.id !== nodeId);

            // Clear selection if the deleted node was selected
            if (gameState.selectedNode && gameState.selectedNode.id === nodeId) {
                gameState.selectedNode = null;
                updateNodeInfoPanel();
            }

            updateCreditsDisplay();
            calculateNodeEfficiency();
            updateNodeVisuals();
            updatePowerDisplay();
        }

        // Start a connection from a node
        function startConnection(node) {
            if (node.outputs.length >= 3) {
                showNotification('Warning', 'This room already has the maximum number of outputs (3).');
                return;
            }

            gameState.isConnecting = true;
            gameState.connectionStartNode = node;

            // Visual feedback
            document.getElementById(`node-${node.id}`).classList.add('selected');
            showNotification('Connect Room', 'Select another room to connect to. Click empty space to cancel.');
        }

        // Finish a connection to a target node
        function finishConnection(targetNode) {
            if (!gameState.isConnecting || !gameState.connectionStartNode) return;

            const sourceNode = gameState.connectionStartNode;

            // Check if already connected
            const alreadyConnected = gameState.connections.some(
                conn => conn.fromId === sourceNode.id && conn.toId === targetNode.id
            );

            if (alreadyConnected) {
                showNotification('Warning', 'These rooms are already connected.');
                cancelConnection();
                return;
            }

            // Check if trying to connect to self
            if (sourceNode.id === targetNode.id) {
                showNotification('Warning', 'Cannot connect a room to itself.');
                cancelConnection();
                return;
            }

            // Check target node input limit
            if (targetNode.inputs.length >= 2) {
                showNotification('Warning', 'Target room already has the maximum number of inputs (2).');
                cancelConnection();
                return;
            }

            // Check for special node types with different connection limits
            if (sourceNode.type === 'junction-node') {
                if (sourceNode.outputs.length >= 3) {
                    showNotification('Warning', 'This Junction Node already has the maximum number of outputs (3).');
                    cancelConnection();
                    return;
                }
            } else if (sourceNode.type === 'power-conduit') {
                if (sourceNode.outputs.length >= 3) {
                    showNotification('Warning', 'This Power Conduit already has the maximum number of outputs (3).');
                    cancelConnection();
                    return;
                }
            } else if (sourceNode.outputs.length >= 3) {
                showNotification('Warning', 'This room already has the maximum number of outputs (3).');
                cancelConnection();
                return;
            }

            // Also in finishConnection, add input restriction for Conduit room:
            if (targetNode.type === 'junction-node' && targetNode.inputs.length >= 1) {
                showNotification('Warning', 'Junction Node can only have 1 input.');
                cancelConnection();
                return;
            } else if (targetNode.type === 'power-conduit' && targetNode.inputs.length >= 2) {
                showNotification('Warning', 'Power Conduit can only have 2 inputs.');
                cancelConnection();
                return;
            } else if (targetNode.inputs.length >= 2) {
                showNotification('Warning', 'Target room already has the maximum number of inputs (2).');
                cancelConnection();
                return;
            }

            // Create the connection
            const connectionId = ++gameState.lastConnectionId;
            const connection = {
                id: connectionId,
                fromId: sourceNode.id,
                toId: targetNode.id
            };

            gameState.connections.push(connection);

            // Update node information
            sourceNode.outputs.push(targetNode.id);
            sourceNode.connections.push(connectionId);

            targetNode.inputs.push(sourceNode.id);
            targetNode.connections.push(connectionId);

            // Draw the connection
            drawConnection(connection);

            // Reset connection state
            document.getElementById(`node-${sourceNode.id}`).classList.remove('selected');
            gameState.isConnecting = false;
            gameState.connectionStartNode = null;

            calculateNodeEfficiency();
            updateNodeVisuals();
            updatePowerDisplay();
        }

        // Remove a specific connection
        function removeConnection(connectionId) {
            const connection = gameState.connections.find(conn => conn.id === connectionId);
            if (!connection) return;

            // Get the nodes
            const sourceNode = gameState.nodes.find(n => n.id === connection.fromId);
            const targetNode = gameState.nodes.find(n => n.id === connection.toId);

            // Remove connection from nodes
            if (sourceNode) {
                sourceNode.outputs = sourceNode.outputs.filter(id => id !== connection.toId);
                sourceNode.connections = sourceNode.connections.filter(id => id !== connection.id);
            }

            if (targetNode) {
                targetNode.inputs = targetNode.inputs.filter(id => id !== connection.fromId);
                targetNode.connections = targetNode.connections.filter(id => id !== connection.id);
            }

            // Remove connection visual elements
            const connElement = document.getElementById(`connection-${connection.id}`);
            if (connElement) {
                connElement.remove();
            }

            const arrowElement = document.getElementById(`arrow-${connection.id}`);
            if (arrowElement) {
                arrowElement.remove();
            }

            // Remove the connection from the game state
            gameState.connections = gameState.connections.filter(conn => conn.id !== connection.id);

            // Recalculate efficiency
            calculateNodeEfficiency();
            updateNodeVisuals();
            updatePowerDisplay();

            // Update info panel if a node is selected
            if (gameState.selectedNode) {
                updateNodeInfoPanel();
            }
        }

        // Calculate the efficiency of all nodes based on connections
        function calculateNodeEfficiency() {
            // Reset all nodes to base values
            gameState.nodes.forEach(node => {
                node.effectivePowerGeneration = node.powerGeneration * (node.durability / 100); // Scale by durability
                node.effectivePowerConsumption = node.powerRequirement;
                node.powerSatisfied = node.powerRequirement === 0;
                node.powerDistributed = 0;
            });

            // Calculate power distribution
            gameState.nodes.forEach(node => {

                // Add special handling for Junction and Conduit in the power distribution section:
                if (node.effectivePowerGeneration > 0 && node.outputs.length > 0) {
                    // This node generates power and has outputs
                    const powerPerOutput = node.effectivePowerGeneration / node.outputs.length;

                    node.outputs.forEach(outputId => {
                        const outputNode = gameState.nodes.find(n => n.id === outputId);
                        if (outputNode) {
                            // Add power to the output node
                            const powerReceived = Math.min(powerPerOutput, outputNode.powerRequirement - outputNode.powerDistributed);
                            outputNode.powerDistributed += powerReceived;

                            // Reduce effective generation due to distribution
                            node.effectivePowerGeneration -= powerReceived;
                        }
                    });
                } else if (node.type === 'junction-node' && node.inputs.length > 0 && node.outputs.length > 0) {
                    // Junction node - gets power from input and distributes to outputs
                    const inputNode = gameState.nodes.find(n => n.id === node.inputs[0]);
                    if (inputNode && inputNode.effectivePowerGeneration > 0) {
                        // Get available power from input
                        const availablePower = Math.min(inputNode.effectivePowerGeneration, 300);

                        // Distribute to outputs
                        const powerPerOutput = availablePower / node.outputs.length;
                        node.outputs.forEach(outputId => {
                            const outputNode = gameState.nodes.find(n => n.id === outputId);
                            if (outputNode) {
                                const powerReceived = Math.min(powerPerOutput, outputNode.powerRequirement - outputNode.powerDistributed);
                                outputNode.powerDistributed += powerReceived;
                            }
                        });
                    }
                } else if (node.type === 'power-conduit' && node.inputs.length > 0 && node.outputs.length > 0) {
                    // Conduit node - combines power from inputs and distributes to outputs
                    let combinedPower = 0;

                    // Get power from each input
                    node.inputs.forEach(inputId => {
                        const inputNode = gameState.nodes.find(n => n.id === inputId);
                        if (inputNode && inputNode.effectivePowerGeneration > 0) {
                            combinedPower += Math.min(inputNode.effectivePowerGeneration, 300);
                        }
                    });

                    // Distribute combined power to outputs
                    if (combinedPower > 0) {
                        const powerPerOutput = combinedPower / node.outputs.length;
                        node.outputs.forEach(outputId => {
                            const outputNode = gameState.nodes.find(n => n.id === outputId);
                            if (outputNode) {
                                const powerReceived = Math.min(powerPerOutput, outputNode.powerRequirement - outputNode.powerDistributed);
                                outputNode.powerDistributed += powerReceived;
                            }
                        });
                    }
                }
            });

            // Update satisfied status
            gameState.nodes.forEach(node => {
                if (node.powerRequirement > 0) {
                    node.powerSatisfied = node.powerDistributed >= node.powerRequirement;
                    node.effectivePowerConsumption = Math.min(node.powerRequirement, node.powerDistributed);
                }
            });

            // Check for requirement satisfaction
            gameState.nodes.forEach(node => {
                if (node.requirements.length > 0) {
                    // Check for power requirement
                    if (node.requirements.includes('power') && !node.powerSatisfied) {
                        node.reqSatisfied = false;
                        return;
                    }

                    // Check for engines requirement
                    if (node.requirements.includes('engines')) {
                        const hasEngineInput = node.inputs.some(inputId => {
                            const inputNode = gameState.nodes.find(n => n.id === inputId);
                            if (!inputNode) return false;
                            const inputRoomType = roomTypes.find(r => r.id === inputNode.type);
                            return inputRoomType && inputRoomType.id.includes('engine');
                        });

                        if (!hasEngineInput) {
                            node.reqSatisfied = false;
                            return;
                        }
                    }

                    // Add checks for other requirement types as needed

                    node.reqSatisfied = true;
                } else {
                    node.reqSatisfied = true;
                }
            });

            // Check if any rooms have unsatisfied requirements and show notification
            const unsatisfiedRooms = gameState.nodes.filter(node => !node.powerSatisfied || !node.reqSatisfied);
            if (unsatisfiedRooms.length > 0) {
                const roomNames = unsatisfiedRooms.map(node => node.name).join(', ');
                const message = `The following rooms have unsatisfied requirements: ${roomNames}`;

                // Only show if there are actually nodes and not during initial loading
                if (gameState.nodes.length > 0 && !window.initializing) {
                    showNotification('Warning', message);
                }
            }
        }

        // Update the visual appearance of nodes based on their status
        function updateNodeVisuals() {
            gameState.nodes.forEach(node => {
                const nodeElement = document.getElementById(`node-${node.id}`);
                if (!nodeElement) return;

                const infoDiv = nodeElement.querySelector('.node-info');
                const titleDiv = nodeElement.querySelector('.node-title');

                // Update title class based on durability
                titleDiv.classList.remove('warning', 'danger');
                if (node.durability <= 30) {
                    titleDiv.classList.add('danger');
                } else if (node.durability <= 60) {
                    titleDiv.classList.add('warning');
                }

                // Update info text
                if (node.powerGeneration > 0) {
                    infoDiv.innerHTML = `
                        <div>Generating: ${Math.floor(node.effectivePowerGeneration)}/${node.powerGeneration}</div>
                        <div class="node-power">${node.reqSatisfied ? '✓' : '⚠️'}</div>
                        <div class="durability-display">Durability: ${Math.floor(node.durability)}%</div>
                    `;
                } else {
                    infoDiv.innerHTML = `
                        <div>Consuming: ${node.effectivePowerConsumption}/${node.powerRequirement}</div>
                        <div class="node-power">${node.powerSatisfied && node.reqSatisfied ? '✓' : '⚠️'}</div>
                        <div class="durability-display">Durability: ${Math.floor(node.durability)}%</div>
                    `;
                }

                // Update border color based on status
                if (!node.powerSatisfied || !node.reqSatisfied) {
                    nodeElement.style.borderColor = 'var(--danger-color)';
                } else {
                    nodeElement.style.borderColor = 'var(--primary-color)';
                }
            });

            // Update selected node info if one is selected
            if (gameState.selectedNode) {
                updateNodeInfoPanel();
            }
        }

        // Draw a connection line between nodes
        function drawConnection(connection) {
            const fromNode = gameState.nodes.find(n => n.id === connection.fromId);
            const toNode = gameState.nodes.find(n => n.id === connection.toId);

            if (!fromNode || !toNode) return;

            const fromElement = document.getElementById(`node-${fromNode.id}`);
            const toElement = document.getElementById(`node-${toNode.id}`);

            if (!fromElement || !toElement) return;

            // Get center positions of nodes
            const fromRect = fromElement.getBoundingClientRect();
            const toRect = toElement.getBoundingClientRect();

            const gridRect = gridElement.getBoundingClientRect();

            const fromX = fromNode.x + fromRect.width / 2;
            const fromY = fromNode.y + fromRect.height / 2;
            const toX = toNode.x + toRect.width / 2;
            const toY = toNode.y + toRect.height / 2;

            // Calculate distance and angle
            const dx = toX - fromX;
            const dy = toY - fromY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            // Create the connection line
            const lineElement = document.createElement('div');
            lineElement.className = 'connection';
            lineElement.id = `connection-${connection.id}`;
            lineElement.style.width = `${distance}px`;
            lineElement.style.left = `${fromX}px`;
            lineElement.style.top = `${fromY}px`;
            lineElement.style.transform = `rotate(${angle}rad)`;

            // Create the arrow
            const arrowElement = document.createElement('div');
            arrowElement.className = 'connection-arrow';
            arrowElement.id = `arrow-${connection.id}`;
            arrowElement.style.left = `${toX - 6}px`;
            arrowElement.style.top = `${toY}px`;
            arrowElement.style.transform = `rotate(${angle + Math.PI / 2}rad)`;

            gridElement.appendChild(lineElement);
            gridElement.appendChild(arrowElement);
        }

        // Redraw all connections
        function redrawConnections() {
            // Remove existing connections
            document.querySelectorAll('.connection, .connection-arrow').forEach(el => el.remove());

            // Redraw all connections
            gameState.connections.forEach(connection => {
                drawConnection(connection);
            });
        }

        // Cancel the current connection attempt
        function cancelConnection() {
            if (gameState.connectionStartNode) {
                document.getElementById(`node-${gameState.connectionStartNode.id}`).classList.remove('selected');
            }

            gameState.isConnecting = false;
            gameState.connectionStartNode = null;
        }

        // Handle mouse down on a node (for dragging)
        function handleNodeMouseDown(event, node) {
            if (gameState.isConnecting) {
                finishConnection(node);
                return;
            }

            if (gameState.deleteMode) {
                deleteNode(node.id);
                return;
            }

            // Select the node and show its details
            selectNode(node);

            // Start dragging
            gameState.draggedNode = node;
            gameState.dragOffsetX = event.clientX - node.x * gameState.gridScale;
            gameState.dragOffsetY = event.clientY - node.y * gameState.gridScale;

            // Add global mouse move and mouse up handlers
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            event.preventDefault();
        }

        // Handle touch start on a node (for mobile)
        function handleNodeTouchStart(event, node) {
            if (gameState.isConnecting) {
                finishConnection(node);
                return;
            }

            if (gameState.deleteMode) {
                deleteNode(node.id);
                return;
            }

            // Select the node and show its details
            selectNode(node);

            // Start dragging
            gameState.draggedNode = node;

            const touch = event.touches[0];
            gameState.dragOffsetX = touch.clientX - node.x * gameState.gridScale;
            gameState.dragOffsetY = touch.clientY - node.y * gameState.gridScale;

            // Add global touch move and touch end handlers
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            event.preventDefault();
        }

        // Handle mouse move for node dragging or panning
        function handleMouseMove(event) {
            if (gameState.draggedNode) {
                // Update node position
                const newX = (event.clientX - gameState.dragOffsetX) / gameState.gridScale;
                const newY = (event.clientY - gameState.dragOffsetY) / gameState.gridScale;

                updateNodePosition(gameState.draggedNode, newX, newY);
            } else if (gameState.isPanning) {
                // Pan the grid
                const dx = event.clientX - gameState.startPanX;
                const dy = event.clientY - gameState.startPanY;

                gameState.gridOffsetX += dx;
                gameState.gridOffsetY += dy;

                updateGridTransform();

                gameState.startPanX = event.clientX;
                gameState.startPanY = event.clientY;
            }
        }

        // Handle touch move for node dragging or panning (mobile)
        function handleTouchMove(event) {
            const touch = event.touches[0];

            if (gameState.draggedNode) {
                // Update node position
                const newX = (touch.clientX - gameState.dragOffsetX) / gameState.gridScale;
                const newY = (touch.clientY - gameState.dragOffsetY) / gameState.gridScale;

                updateNodePosition(gameState.draggedNode, newX, newY);
                event.preventDefault();
            } else if (gameState.isPanning) {
                // Pan the grid
                const dx = touch.clientX - gameState.startPanX;
                const dy = touch.clientY - gameState.startPanY;

                gameState.gridOffsetX += dx;
                gameState.gridOffsetY += dy;

                updateGridTransform();

                gameState.startPanX = touch.clientX;
                gameState.startPanY = touch.clientY;
                event.preventDefault();
            }
        }

        // Handle mouse up event
        function handleMouseUp() {
            // Stop dragging or panning
            gameState.draggedNode = null;
            gameState.isPanning = false;

            // Remove the event listeners
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }

        // Handle touch end event (mobile)
        function handleTouchEnd() {
            // Stop dragging or panning
            gameState.draggedNode = null;
            gameState.isPanning = false;

            // Remove the event listeners
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }

        // Update a node's position
        function updateNodePosition(node, x, y) {
            node.x = x;
            node.y = y;

            const nodeElement = document.getElementById(`node-${node.id}`);
            if (nodeElement) {
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
            }

            redrawConnections();
        }

        function handlePinchStart(e) {
            if (e.touches.length === 2) {
                initialPinchDistance = getPinchDistance(e.touches);
            }
        }

        function handlePinchMove(e) {
            if (e.touches.length === 2) {
                const currentDistance = getPinchDistance(e.touches);
                const scaleFactor = currentDistance / initialPinchDistance;

                if (Math.abs(scaleFactor - 1) > 0.05) {
                    zoomGrid(scaleFactor > 1 ? 1.05 : 0.95);
                    initialPinchDistance = currentDistance;
                    e.preventDefault(); // Prevent default zoom
                }
            }
        }

        function getPinchDistance(touches) {
            return Math.hypot(
                touches[0].clientX - touches[1].clientX,
                touches[0].clientY - touches[1].clientY
            );
        }

        // Handle grid mouse down for panning and placing nodes
        function handleGridMouseDown(event) {
            // Ignore if clicked on a node or connection
            if (event.target.closest('.node') ||
                event.target.closest('.connection') ||
                event.target.closest('.connection-arrow')) {
                return;
            }

            const gridRect = gridElement.getBoundingClientRect();
            const x = (event.clientX - gridRect.left - gameState.gridOffsetX) / gameState.gridScale;
            const y = (event.clientY - gridRect.top - gameState.gridOffsetY) / gameState.gridScale;

            if (gameState.selectedRoomType) {
                // Create a new node
                createNode(x, y);
                gameState.selectedRoomType = null;
                document.querySelectorAll('.room-item').forEach(el => {
                    el.style.backgroundColor = '';
                });
            } else if (gameState.isConnecting) {
                // Cancel connection attempt
                cancelConnection();
            } else {
                // Start panning
                gameState.isPanning = true;
                gameState.startPanX = event.clientX;
                gameState.startPanY = event.clientY;

                // Add global mouse move and mouse up handlers
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }
        }

        // Handle grid touch start for panning and placing nodes (mobile)
        function handleGridTouchStart(event) {
            // Ignore if touched on a node or connection
            if (event.target.closest('.node') ||
                event.target.closest('.connection') ||
                event.target.closest('.connection-arrow')) {
                return;
            }

            const touch = event.touches[0];
            const gridRect = gridElement.getBoundingClientRect();
            const x = (touch.clientX - gridRect.left - gameState.gridOffsetX) / gameState.gridScale;
            const y = (touch.clientY - gridRect.top - gameState.gridOffsetY) / gameState.gridScale;

            if (gameState.selectedRoomType) {
                // Create a new node
                createNode(x, y);
                gameState.selectedRoomType = null;
                document.querySelectorAll('.room-item').forEach(el => {
                    el.style.backgroundColor = '';
                });
            } else if (gameState.isConnecting) {
                // Cancel connection attempt
                cancelConnection();
            } else {
                // Start panning
                gameState.isPanning = true;
                gameState.startPanX = touch.clientX;
                gameState.startPanY = touch.clientY;

                // Add global touch move and touch end handlers
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);
            }
        }

        // Zoom the grid
        function zoomGrid(factor) {
            const prevScale = gameState.gridScale;
            gameState.gridScale *= factor;

            // Limit the zoom scale
            gameState.gridScale = Math.max(0.2, Math.min(2, gameState.gridScale));

            // Adjust the offset to maintain the center point
            const gridRect = gridElement.getBoundingClientRect();
            const centerX = gridRect.width / 2;
            const centerY = gridRect.height / 2;

            const scaleFactor = gameState.gridScale / prevScale;

            gameState.gridOffsetX = centerX - (centerX - gameState.gridOffsetX) * scaleFactor;
            gameState.gridOffsetY = centerY - (centerY - gameState.gridOffsetY) * scaleFactor;

            updateGridTransform();
            redrawConnections();
        }

        // Update the grid transform
        function updateGridTransform() {
            gridElement.style.transform = `translate(${gameState.gridOffsetX}px, ${gameState.gridOffsetY}px) scale(${gameState.gridScale})`;
        }

        // Center the grid view
        function centerGridView() {
            const gridRect = gridElement.getBoundingClientRect();
            gameState.gridOffsetX = gridRect.width / 2 - 1500;
            gameState.gridOffsetY = gridRect.height / 2 - 1500;
            gameState.gridScale = 1;

            updateGridTransform();
        }

        // Select a node and show its details
        function selectNode(node) {
            // Deselect previous node if any
            if (gameState.selectedNode) {
                const prevElement = document.getElementById(`node-${gameState.selectedNode.id}`);
                if (prevElement) {
                    prevElement.classList.remove('selected');
                }
            }

            gameState.selectedNode = node;

            const nodeElement = document.getElementById(`node-${node.id}`);
            if (nodeElement) {
                nodeElement.classList.add('selected');
            }

            updateNodeInfoPanel();
        }

        // Update the node info panel with selected node details
        function updateNodeInfoPanel() {
            if (!gameState.selectedNode) {
                noSelection.style.display = 'block';
                selectionDetails.style.display = 'none';
                return;
            }

            noSelection.style.display = 'none';
            selectionDetails.style.display = 'block';

            const node = gameState.selectedNode;
            const roomType = roomTypes.find(r => r.id === node.type);

            document.getElementById('detail-type').textContent = node.name;
            document.getElementById('detail-room-type').textContent = roomType.type;
            document.getElementById('detail-universe').textContent = roomType.universe.replace('-', ' ');
            document.getElementById('detail-power-gen').textContent = node.powerGeneration > 0 ? `${node.effectivePowerGeneration}/${node.powerGeneration}` : '0';
            document.getElementById('detail-power-req').textContent = node.powerRequirement > 0 ? `${node.powerRequirement}` : '0';
            document.getElementById('detail-current-power').textContent = node.powerSatisfied ? 'Satisfied' : `Needs more power`;

            // Show requirements
            let requirementsText = node.requirements.length > 0 ?
                node.requirements.join(', ') : 'None';
            document.getElementById('detail-requirements').textContent = requirementsText;

            // Show connections
            let connectionsText = '';
            if (node.outputs.length > 0) {
                connectionsText += 'Outputs: ';
                node.outputs.forEach((outputId, index) => {
                    const outputNode = gameState.nodes.find(n => n.id === outputId);
                    if (outputNode) {
                        connectionsText += outputNode.name;
                        if (index < node.outputs.length - 1) {
                            connectionsText += ', ';
                        }
                    }
                });
            }

            if (node.inputs.length > 0) {
                if (connectionsText) connectionsText += ' | ';
                connectionsText += 'Inputs: ';
                node.inputs.forEach((inputId, index) => {
                    const inputNode = gameState.nodes.find(n => n.id === inputId);
                    if (inputNode) {
                        connectionsText += inputNode.name;
                        if (index < node.inputs.length - 1) {
                            connectionsText += ', ';
                        }
                    }
                });
            }

            if (!connectionsText) connectionsText = 'None';
            document.getElementById('detail-connections').textContent = connectionsText;
        }

        // Show diagnostic information
        function showDiagnostics() {
            const statusContent = document.getElementById('status-content');

            // Calculate power stats
            let totalPower = 0;
            let usedPower = 0;
            let surplusPower = 0;

            // Room counts
            let totalRooms = gameState.nodes.length;
            let powerRooms = 0;
            let engineRooms = 0;
            let commandRooms = 0;
            let tacticalRooms = 0;
            let utilityRooms = 0;

            // Durability stats
            let totalDurability = 0;
            let roomsNeedingRepair = 0;

            // Calculate all stats
            gameState.nodes.forEach(node => {
                // Power calculations
                if (node.effectivePowerGeneration > 0) {
                    totalPower += node.effectivePowerGeneration;
                }
                if (node.effectivePowerConsumption > 0) {
                    usedPower += node.effectivePowerConsumption;
                }

                // Room type counts - this is the corrected part
                const roomType = roomTypes.find(r => r.id === node.type);
                if (roomType) {
                    if (roomType.type === 'power') powerRooms++;
                    else if (roomType.type === 'engines') engineRooms++;
                    else if (roomType.type === 'command') commandRooms++;
                    else if (roomType.type === 'tactical') tacticalRooms++;
                    else if (roomType.type === 'utility') utilityRooms++;
                }

                // Durability stats
                totalDurability += node.durability;
                if (node.durability < 90) roomsNeedingRepair++;
            });

            // Calculate averages and efficiencies
            surplusPower = totalPower - usedPower;
            const avgDurability = totalRooms > 0 ? Math.floor(totalDurability / totalRooms) : 0;

            // Calculate economic projections
            const baseIncome = 100; // Base income per day
            let efficiencyMultiplier = 1.0;

            // Factors affecting income
            efficiencyMultiplier += totalRooms * 0.1; // More rooms = more income
            efficiencyMultiplier -= (roomsNeedingRepair * 0.05); // Damaged rooms reduce efficiency

            // Surplus power increases efficiency
            if (surplusPower > 0) {
                efficiencyMultiplier += Math.min(1.0, surplusPower / 500);
            }

            // Calculate projected earnings and maintenance
            const projectedDailyIncome = Math.floor(baseIncome * efficiencyMultiplier);
            const projectedFiveDayIncome = projectedDailyIncome * 5;

            // Maintenance cost is based on room count and average durability
            const dailyMaintenanceCost = Math.floor(totalRooms * 10 * (1 + (90 - avgDurability) / 100));
            const fiveDayMaintenanceCost = dailyMaintenanceCost * 5;

            // Calculate net profit
            const netProfit = projectedFiveDayIncome - fiveDayMaintenanceCost;

            const faction = factions[gameState.selectedFaction];

            // Check faction requirements before displaying them
            if (gameState.selectedFaction) {
                checkFactionRequirements();
            }

            // Create the diagnostic report
            statusContent.innerHTML = `
        <div>
            <h3>Ship Diagnostics Report</h3>
            <p>Total Rooms: ${totalRooms}</p>
            <p>Average Durability: ${avgDurability}%</p>
            <p>Rooms Needing Repair: ${roomsNeedingRepair}</p>
        </div><br>
        <div>
            <h3>Power Systems</h3>
            <p>Total Power Generation: ${Math.floor(totalPower)}</p>
            <p>Power Consumption: ${Math.floor(usedPower)}</p>
            <p>Surplus Power: ${Math.floor(surplusPower)}</p>
            <p>Power Efficiency: ${totalPower > 0 ? Math.floor((usedPower / totalPower) * 100) : 0}%</p>
        </div><br>
        <div>
            <h3>Room Composition</h3>
            <p>Power Systems: ${powerRooms}</p>
            <p>Engine Rooms: ${engineRooms}</p>
            <p>Command Rooms: ${commandRooms}</p>
            <p>Tactical Systems: ${tacticalRooms}</p>
            <p>Utility Rooms: ${utilityRooms}</p>
        </div><br>
        <div>
            <h3>Financial Projections (5-day run)</h3>
            <p>Estimated Daily Income: ${projectedDailyIncome} credits</p>
            <p>5-Day Income: ${projectedFiveDayIncome} credits</p>
            <p>Daily Maintenance Cost: ${dailyMaintenanceCost} credits</p>
            <p>5-Day Maintenance: ${fiveDayMaintenanceCost} credits</p>
            <p>Projected Net Profit: ${netProfit} credits</p>
        </div><br>

            <div>
                <h3>Faction Requirements</h3>
                <p>Your ${faction.name} requires:</p>
                <ul>
        `;

            // Add requirements
            for (const [type, count] of Object.entries(faction.requiredRooms)) {
                statusContent.innerHTML += `<li>${count} ${type} room(s)</li>`;
            }

            statusContent.innerHTML += `</ul>
                <p>Status: ${gameState.factionRequirementsMet ? 'Requirements Met ✓' : 'Requirements Not Met ✗'}</p>
            </div>
    `;



            statusModal.style.display = 'flex';

        }

        // Calculate repair costs and show confirmation
        function showRepairConfirmation() {
            const repairModal = document.getElementById('repair-modal');
            const repairContent = document.getElementById('repair-content');

            let totalRepairCost = 0;
            let totalRepairAmount = 0;
            let roomsToRepair = 0;

            // Calculate repair needs and costs
            gameState.nodes.forEach(node => {
                if (node.durability < 90) {
                    const repairAmount = 90 - node.durability;
                    totalRepairAmount += repairAmount;
                    roomsToRepair++;

                    // Cost formula: repair amount * 5 * room base cost / 100
                    const roomType = roomTypes.find(r => r.id === node.type);
                    const roomCost = roomType ? roomType.cost : 500;
                    totalRepairCost += Math.floor(repairAmount * 5 * roomCost / 100);
                }
            });

            // If no repairs needed
            if (roomsToRepair === 0) {
                repairContent.innerHTML = `
            <p>All rooms are in good condition (90% durability or higher).</p>
            <p>No repairs needed at this time.</p>
        `;

                // Hide the confirm button
                document.getElementById('confirm-repair').style.display = 'none';
            } else {
                repairContent.innerHTML = `
            <p>${roomsToRepair} room(s) need repair.</p>
            <p>Average repair amount: ${Math.floor(totalRepairAmount / roomsToRepair)}%</p>
            <p>Total repair cost: ${totalRepairCost} credits</p>
            <p>All rooms will be repaired to at least 90% durability.</p>
            <p>Do you want to proceed with repairs?</p>
        `;

                // Show the confirm button
                document.getElementById('confirm-repair').style.display = 'block';

                // Store the cost for the confirmation handler
                gameState.pendingRepairCost = totalRepairCost;
            }

            repairModal.style.display = 'flex';
        }

        // Perform the actual repairs
        function repairShip() {
            const repairCost = gameState.pendingRepairCost || 0;

            // Check if player has enough credits
            if (gameState.credits < repairCost) {
                showNotification('Error', 'Not enough credits for repairs.');
                return;
            }

            // Apply repairs and deduct cost
            let roomsRepaired = 0;

            gameState.nodes.forEach(node => {
                if (node.durability < 90) {
                    node.durability = 90 + Math.random() * 10; // Between 90% and 100%
                    roomsRepaired++;
                }
            });

            // Deduct credits
            gameState.credits -= repairCost;
            updateCreditsDisplay();

            // Update visuals
            updateNodeVisuals();

            // Close modal and notify
            document.getElementById('repair-modal').style.display = 'none';
            showNotification('Repairs Complete', `${roomsRepaired} room(s) repaired successfully for ${repairCost} credits.`);
        }

        // Show the ship status modal with detailed information
        function showShipStatus() {
            const statusContent = document.getElementById('status-content');

            let totalPower = 0;
            let usedPower = 0;
            let unsatisfiedRooms = 0;

            gameState.nodes.forEach(node => {
                if (node.effectivePowerGeneration > 0) {
                    totalPower += node.effectivePowerGeneration;
                }
                if (node.effectivePowerConsumption > 0 && node.powerSatisfied) {
                    usedPower += node.effectivePowerConsumption;
                }
                if (!node.powerSatisfied || !node.reqSatisfied) {
                    unsatisfiedRooms++;
                }
            });

            const roomsByUniverse = {};
            gameState.nodes.forEach(node => {
                if (!roomsByUniverse[node.universe]) {
                    roomsByUniverse[node.universe] = 0;
                }
                roomsByUniverse[node.universe]++;
            });

            let universeBreakdown = '';
            for (const [universe, count] of Object.entries(roomsByUniverse)) {
                universeBreakdown += `<li>${universe.replace('-', ' ')}: ${count} room(s)</li>`;
            }

            statusContent.innerHTML = `
                <div>
                    <h3>Power Status</h3>
                    <p>Total Power Generation: ${Math.floor(totalPower)}</p>
                    <p>Power Consumption: ${Math.floor(usedPower)}</p>
                    <p>Available Power: ${Math.floor(totalPower - usedPower)}</p>
                </div>
                <div>
                    <h3>Ship Composition</h3>
                    <p>Total Rooms: ${gameState.nodes.length}</p>
                    <p>Rooms with Issues: ${unsatisfiedRooms}</p>
                    <h4>Rooms by Universe:</h4>
                    <ul>${universeBreakdown}</ul>
                </div>
                <div>
                    <h3>Resources</h3>
                    <p>Credits: ${gameState.credits.toLocaleString()}</p>
                </div>
            `;

            statusModal.style.display = 'flex';
        }

        // Show a notification message
        function showNotification(title, message) {
            const modal = document.getElementById('notification-modal');
            const titleEl = document.getElementById('notification-title');
            const contentEl = document.getElementById('notification-content');

            titleEl.textContent = title;
            contentEl.textContent = message;

            modal.classList.add('show');

            // Auto-hide after 4 seconds
            setTimeout(() => {
                modal.classList.remove('show');
            }, 4000);
        }

        // Show the connections modal
        function showConnectionsModal(node) {
            const connectionsModal = document.getElementById('connections-modal');
            const connectionsContent = document.getElementById('connections-content');

            // Gather connections information
            let content = `<h3>${node.name} Connections</h3>`;

            // Display outputs
            if (node.outputs.length > 0) {
                content += '<h4>Outputs:</h4>';
                node.outputs.forEach(outputId => {
                    const outputNode = gameState.nodes.find(n => n.id === outputId);
                    if (outputNode) {
                        const connectionId = gameState.connections.find(
                            conn => conn.fromId === node.id && conn.toId === outputId
                        )?.id;

                        content += `
                            <div class="connection-item">
                                <span>${outputNode.name}</span>
                                <span class="unlink-btn" data-connection-id="${connectionId}">✕</span>
                            </div>
                        `;
                    }
                });
            } else {
                content += '<p>No output connections.</p>';
            }

            // Display inputs
            if (node.inputs.length > 0) {
                content += '<h4>Inputs:</h4>';
                node.inputs.forEach(inputId => {
                    const inputNode = gameState.nodes.find(n => n.id === inputId);
                    if (inputNode) {
                        const connectionId = gameState.connections.find(
                            conn => conn.fromId === inputId && conn.toId === node.id
                        )?.id;

                        content += `
                            <div class="connection-item">
                                <span>${inputNode.name}</span>
                                <span class="unlink-btn" data-connection-id="${connectionId}">✕</span>
                            </div>
                        `;
                    }
                });
            } else {
                content += '<p>No input connections.</p>';
            }

            connectionsContent.innerHTML = content;

            // Add event listeners to unlink buttons
            connectionsContent.querySelectorAll('.unlink-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const connectionId = parseInt(btn.dataset.connectionId);
                    removeConnection(connectionId);
                    showConnectionsModal(node); // Refresh the modal
                });
            });

            // Show the modal
            connectionsModal.style.display = 'flex';
        }

        // Run jobs for specified number of days
        // function runJobs() {
        //     const daysInput = document.getElementById('job-days');
        //     const days = parseInt(daysInput.value);

        //     if (isNaN(days) || days < 1 || days > 30) {
        //         showNotification('Invalid Input', 'Please enter a number between 1 and 30 days.');
        //         return;
        //     }

        //     // Check if ship has any functional rooms
        //     if (gameState.nodes.length === 0) {
        //         showNotification('Error', 'You need to build some rooms first!');
        //         return;
        //     }

        //     // Check faction requirements first
        //     if (gameState.selectedFaction) {
        //         checkFactionRequirements();

        //         if (!gameState.factionRequirementsMet) {
        //             showNotification('Cannot Run Jobs', `Your ship does not meet the minimum requirements for a ${factions[gameState.selectedFaction].name}. Check the diagnostics for details.`);
        //             return;
        //         }
        //     }

        //     // Calculate ship efficiency score
        //     let totalPower = 0;
        //     let usedPower = 0;
        //     let unsatisfiedRooms = 0;
        //     let totalRooms = gameState.nodes.length;

        //     gameState.nodes.forEach(node => {
        //         if (node.effectivePowerGeneration > 0) {
        //             totalPower += node.effectivePowerGeneration;
        //         }
        //         if (node.effectivePowerConsumption > 0 && node.powerSatisfied) {
        //             usedPower += node.effectivePowerConsumption;
        //         }
        //         if (!node.powerSatisfied || !node.reqSatisfied) {
        //             unsatisfiedRooms++;
        //         }
        //     });

        //     // Base income per day
        //     const baseIncome = 100;

        //     // Efficiency multiplier (higher is better)
        //     let efficiencyMultiplier = 1.0;

        //     // More rooms = more income
        //     efficiencyMultiplier += totalRooms * 0.1;

        //     // Unsatisfied rooms reduce efficiency
        //     efficiencyMultiplier -= unsatisfiedRooms * 0.2;

        //     // Surplus power increases efficiency
        //     const surplusPower = totalPower - usedPower;
        //     if (surplusPower > 0) {
        //         efficiencyMultiplier += Math.min(1.0, surplusPower / 500);
        //     }

        //     // Calculate total income
        //     let totalIncome = Math.max(0, Math.floor(baseIncome * efficiencyMultiplier * days));

        //     // Apply faction income multiplier if applicable
        //     // if (gameState.selectedFaction) {
        //         const factionMultiplier = factions[gameState.selectedFaction].incomeMultiplier;
        //         // const baseIncome = totalIncome;
        //         totalIncome = Math.floor(totalIncome * factionMultiplier);

        //         // Show notification about faction bonus/penalty
        //         const difference = totalIncome - baseIncome;
        //         if (difference !== 0) {
        //             if (difference > 0) {
        //                 showNotification('Faction Bonus', `Your ${factions[gameState.selectedFaction].name} earned a bonus of ${difference} credits.`);
        //             } else {
        //                 showNotification('Independent Penalty', `Your ${factions[gameState.selectedFaction].name} status resulted in a penalty of ${Math.abs(difference)} credits.`);
        //             }
        //         }
        //     // }

        //     // Update room durability
        //     const roomsToDelete = [];

        //     gameState.nodes.forEach(node => {
        //         // Base durability reduction per day (3-7%)
        //         const baseDurabilityLoss = 3 + Math.random() * 4;

        //         // Additional reduction based on requirements not being met
        //         let durabilityLoss = baseDurabilityLoss;

        //         if (!node.powerSatisfied || !node.reqSatisfied) {
        //             durabilityLoss *= 1.5; // 50% more wear if requirements not met
        //         }

        //         // Cap at 10% per day as requested
        //         durabilityLoss = Math.min(10, durabilityLoss);

        //         // Apply durability loss for all days
        //         node.durability -= durabilityLoss * days;

        //         // Check if room needs to be scrapped
        //         if (node.durability <= 0) {
        //             roomsToDelete.push(node.id);
        //         }
        //     });

        //     // Remove rooms with 0 durabilityF
        //     roomsToDelete.forEach(nodeId => {
        //         deleteNode(nodeId);
        //     });

        //     gameState.lastJobIncome = totalIncome;

        //     // Add income to credits
        //     gameState.credits += totalIncome;

        //     // Update displays
        //     updateCreditsDisplay();
        //     calculateNodeEfficiency();
        //     updateNodeVisuals();
        //     updatePowerDisplay();

        //     // Show summary
        //     showNotification('Job Complete',
        //         `Completed ${days} days of jobs.\nEarned ${totalIncome} credits.\n${roomsToDelete.length} rooms were scrapped due to 0% durability.`);
        // }

        // Run jobs for specified number of days
        function runJobs() {

            showShipAnimation();

            const daysInput = document.getElementById('job-days');
            const days = parseInt(daysInput.value);

            if (isNaN(days) || days < 1 || days > 30) {
                showNotification('Invalid Input', 'Please enter a number between 1 and 30 days.');
                return;
            }

            // Check if ship has any functional rooms
            if (gameState.nodes.length === 0) {
                showNotification('Error', 'You need to build some rooms first!');
                return;
            }

            // Check faction requirements first
            if (gameState.selectedFaction) {
                checkFactionRequirements();

                if (!gameState.factionRequirementsMet) {
                    showNotification('Cannot Run Jobs', `Your ship does not meet the minimum requirements for a ${factions[gameState.selectedFaction].name}. Check the diagnostics for details.`);
                    return;
                }
            }

            // Calculate ship efficiency score
            let totalPower = 0;
            let usedPower = 0;
            let unsatisfiedRooms = 0;
            let totalRooms = gameState.nodes.length;

            gameState.nodes.forEach(node => {
                if (node.effectivePowerGeneration > 0) {
                    totalPower += node.effectivePowerGeneration;
                }
                if (node.effectivePowerConsumption > 0 && node.powerSatisfied) {
                    usedPower += node.effectivePowerConsumption;
                }
                if (!node.powerSatisfied || !node.reqSatisfied) {
                    unsatisfiedRooms++;
                }
            });

            // Base income per day
            const baseIncome = 100;

            // Efficiency multiplier (higher is better)
            let efficiencyMultiplier = 1.0;

            // More rooms = more income
            efficiencyMultiplier += totalRooms * 0.1;

            // Unsatisfied rooms reduce efficiency
            efficiencyMultiplier -= unsatisfiedRooms * 0.2;

            // Surplus power increases efficiency
            const surplusPower = totalPower - usedPower;
            if (surplusPower > 0) {
                efficiencyMultiplier += Math.min(1.0, surplusPower / 500);
            }

            // Calculate total income before faction multiplier
            let totalIncome = Math.max(0, Math.floor(baseIncome * efficiencyMultiplier * days));
            let factionBonusMessage = "";

            // Apply faction income multiplier if applicable
            if (gameState.selectedFaction) {
                const factionMultiplier = factions[gameState.selectedFaction].incomeMultiplier;
                const preMultiplierIncome = totalIncome;
                totalIncome = Math.floor(totalIncome * factionMultiplier);

                // Calculate the difference for notification
                const difference = totalIncome - preMultiplierIncome;
                if (difference !== 0) {
                    if (difference > 0) {
                        factionBonusMessage = `\nFaction Bonus: +${difference} credits`;
                    } else {
                        factionBonusMessage = `\nFaction Penalty: -${Math.abs(difference)} credits`;
                    }
                }
            }

            gameState.lastJobIncome = totalIncome;

            // Update room durability
            const roomsToDelete = [];

            gameState.nodes.forEach(node => {
                // Base durability reduction per day (3-7%)
                const baseDurabilityLoss = 3 + Math.random() * 4;

                // Additional reduction based on requirements not being met
                let durabilityLoss = baseDurabilityLoss;

                if (!node.powerSatisfied || !node.reqSatisfied) {
                    durabilityLoss *= 1.5; // 50% more wear if requirements not met
                }

                // Cap at 10% per day as requested
                durabilityLoss = Math.min(10, durabilityLoss);

                // Apply durability loss for all days
                node.durability -= durabilityLoss * days;

                // Check if room needs to be scrapped
                if (node.durability <= 0) {
                    roomsToDelete.push(node.id);
                }
            });

            // Remove rooms with 0 durability
            roomsToDelete.forEach(nodeId => {
                deleteNode(nodeId);
            });

            // Add income to credits
            gameState.credits += totalIncome;

            // Update displays
            updateCreditsDisplay();
            calculateNodeEfficiency();
            updateNodeVisuals();
            updatePowerDisplay();

            // Show summary with faction bonus/penalty included
            showNotification('Job Complete',
                `Completed ${days} days of jobs.\nEarned ${totalIncome} credits.${factionBonusMessage}\n${roomsToDelete.length} rooms were scrapped due to 0% durability.`);
        }

        // Function to prepare ship data for export
        function prepareShipData() {
            const shipName = document.getElementById('ship-name').value.trim() || 'Unnamed Ship';

            // Prepare the ship data
            const shipData = {
                name: shipName,
                credits: gameState.credits,
                lastNodeId: gameState.lastNodeId,
                lastConnectionId: gameState.lastConnectionId,
                nodes: gameState.nodes,
                connections: gameState.connections,
                timestamp: Date.now()
            };

            return shipData;
        }

        // Export ship as JSON file
        function exportAsJSON() {
            const shipData = prepareShipData();

            // Convert to JSON string
            const jsonString = JSON.stringify(shipData, null, 2);

            // Create download link
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `${shipData.name.replace(/\s+/g, '_')}.json`);

            // Trigger download
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();

            showNotification('Ship Exported', `${shipData.name} has been exported as JSON file.`);
        }

        // Generate QR code for ship data
        function generateQRCode() {
            const shipData = prepareShipData();
            const jsonString = JSON.stringify(shipData);

            // Check data size
            if (jsonString.length > 2500) {
                showNotification('Warning', 'Ship design is too complex for QR code. Try simplifying or use JSON export.');
                return;
            }

            // Generate QR code
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = '';

            // Use QRCode library
            const qr = qrcode(0, 'L');
            qr.addData(jsonString);
            qr.make();

            // Generate SVG with proper sizing
            qrContainer.innerHTML = qr.createSvgTag(5, 0);

            // Show QR code container
            document.getElementById('qr-container').style.display = 'block';

            // Update ship name in modal
            document.getElementById('export-ship-name').textContent = shipData.name;
        }

        // Download QR code as image
        function downloadQRCode() {
            const qrSvg = document.querySelector('#qrcode svg');
            const shipName = document.getElementById('ship-name').value.trim() || 'Unnamed Ship';

            // Convert SVG to canvas and download
            const svgData = new XMLSerializer().serializeToString(qrSvg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = function () {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                // Convert to downloadable link
                const a = document.createElement('a');
                a.download = `${shipName.replace(/\s+/g, '_')}_QR.png`;
                a.href = canvas.toDataURL('image/png');
                a.click();
            };

            img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
        }

        // Import ship from file (JSON or QR image)
        function importFromFile() {
            const fileInput = document.getElementById('import-file');
            const file = fileInput.files[0];

            if (!file) {
                showNotification('Error', 'Please select a file to import.');
                return;
            }

            if (file.type === 'application/json') {
                // Handle JSON file
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        importShipFromJSON(e.target.result);
                    } catch (error) {
                        showNotification('Error', 'Invalid ship data: ' + error.message);
                    }
                };
                reader.readAsText(file);
            } else if (file.type.startsWith('image/')) {
                // Handle image file (QR code)
                const reader = new FileReader();
                reader.onload = function (e) {
                    decodeQRFromImage(e.target.result);
                };
                reader.readAsDataURL(file);
            } else {
                showNotification('Error', 'Unsupported file type. Please use JSON or image files.');
            }
        }

        // Decode QR code from image
        function decodeQRFromImage(imageDataUrl) {
            const img = new Image();
            img.onload = function () {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    try {
                        importShipFromJSON(code.data);
                    } catch (error) {
                        showNotification('Error', 'Invalid QR code data: ' + error.message);
                    }
                } else {
                    showNotification('Error', 'No QR code found in the image.');
                }
            };
            img.src = imageDataUrl;
        }

        // Start QR code scanning with camera
        function startQRScanner() {
            const video = document.getElementById('scanner-video');
            const scannerContainer = document.getElementById('scanner-container');

            scannerContainer.style.display = 'block';

            // Request camera access
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                .then(function (stream) {
                    video.srcObject = stream;
                    video.setAttribute('playsinline', true); // Required for iOS
                    video.play();
                    requestAnimationFrame(scanQRCodeFrame);
                })
                .catch(function (err) {
                    showNotification('Error', 'Camera access denied or not available: ' + err.message);
                    scannerContainer.style.display = 'none';
                });
        }

        // Process video frames for QR scanning
        function scanQRCodeFrame() {
            const video = document.getElementById('scanner-video');

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    // Stop camera
                    stopQRScanner();

                    // Process the QR code data
                    try {
                        importShipFromJSON(code.data);
                    } catch (error) {
                        showNotification('Error', 'Invalid QR code data: ' + error.message);
                    }
                }
            }

            // Continue scanning
            requestAnimationFrame(scanQRCodeFrame);
        }

        // Stop QR scanner
        function stopQRScanner() {
            const video = document.getElementById('scanner-video');
            const scannerContainer = document.getElementById('scanner-container');

            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }

            scannerContainer.style.display = 'none';
        }

        // Import ship from JSON string
        function importShipFromJSON(jsonString) {
            try {
                const shipData = JSON.parse(jsonString);

                // Validate ship data
                if (!shipData.name || !Array.isArray(shipData.nodes) || !Array.isArray(shipData.connections)) {
                    showNotification('Error', 'Invalid ship data format.');
                    return;
                }

                // Clear current ship
                clearShip();

                // Load ship data
                document.getElementById('ship-name').value = shipData.name;
                gameState.credits = shipData.credits;
                gameState.lastNodeId = shipData.lastNodeId || 0;
                gameState.lastConnectionId = shipData.lastConnectionId || 0;

                // Create nodes
                shipData.nodes.forEach(node => {
                    gameState.nodes.push(node);
                    renderNode(node);
                });

                // Create connections
                shipData.connections.forEach(connection => {
                    gameState.connections.push(connection);
                    drawConnection(connection);
                });

                // Update displays
                updateCreditsDisplay();
                calculateNodeEfficiency();
                updateNodeVisuals();
                updatePowerDisplay();

                // Close modal
                document.getElementById('load-modal').style.display = 'none';

                showNotification('Ship Imported', `${shipData.name} has been imported successfully.`);
            } catch (error) {
                showNotification('Error', 'Failed to import ship: ' + error.message);
            }
        }

        // Clear the current ship
        function clearShip() {
            // Remove all node elements
            document.querySelectorAll('.node').forEach(node => node.remove());

            // Remove all connection elements
            document.querySelectorAll('.connection, .connection-arrow').forEach(conn => conn.remove());

            // Reset game state
            gameState.nodes = [];
            gameState.connections = [];
            gameState.selectedNode = null;

            // Update node info panel
            updateNodeInfoPanel();
        }


        // Initialize the visualization with CSS shapes
        function initShipVisualization() {
            const visualModal = document.getElementById('visual-ship-modal');
            const shipCanvas = document.getElementById('ship-canvas');
            const componentsList = document.getElementById('components-list');

            // Add direction indicators to canvas
            const frontIndicator = document.createElement('div');
            frontIndicator.className = 'direction-indicator front';
            frontIndicator.innerHTML = '← FRONT';
            frontIndicator.style.position = 'absolute';
            frontIndicator.style.left = '20px';
            frontIndicator.style.top = '10px';
            frontIndicator.style.color = 'rgba(255,255,255,0.7)';
            frontIndicator.style.fontWeight = 'bold';
            frontIndicator.style.pointerEvents = 'none';
            shipCanvas.appendChild(frontIndicator);

            const rearIndicator = document.createElement('div');
            rearIndicator.className = 'direction-indicator rear';
            rearIndicator.innerHTML = 'REAR →';
            rearIndicator.style.position = 'absolute';
            rearIndicator.style.right = '20px';
            rearIndicator.style.top = '10px';
            rearIndicator.style.color = 'rgba(255,255,255,0.7)';
            rearIndicator.style.fontWeight = 'bold';
            rearIndicator.style.pointerEvents = 'none';
            shipCanvas.appendChild(rearIndicator);

            // Clear previous contents
            shipCanvas.innerHTML = '';
            componentsList.innerHTML = '';

            // Store positioned components
            gameState.shipDesign = gameState.shipDesign || [];

            // Define component styles by type
            const componentStyles = {
                'power': {
                    name: 'Power Core',
                    color: '#f1c40f',
                    shape: 'power-core',
                    category: 'power',
                    width: 80,
                    height: 80
                },
                'engines': {
                    name: 'Engines',
                    color: '#e67e22',
                    shape: 'engines',
                    category: 'engine',
                    width: 120,
                    height: 60
                },
                'command': {
                    name: 'Command Bridge',
                    color: '#3498db',
                    shape: 'trapezoid',
                    category: 'command',
                    width: 100,
                    height: 60
                },
                'tactical': {
                    name: 'Weapons System',
                    color: '#9b59b6',
                    shape: 'diamond',
                    category: 'tactical',
                    width: 70,
                    height: 70
                },
                'utility': {
                    name: 'Utility Room',
                    color: '#1abc9c',
                    shape: 'hexagon',
                    category: 'utility',
                    width: 60,
                    height: 60
                },
                'hull': {
                    name: 'Hull Section',
                    color: '#95a5a6',
                    shape: 'rectangle',
                    category: 'hull',
                    width: 150,
                    height: 80
                }
            };

            // Add hull sections by default
            // const availableComponents = [
            //     { id: 'hull-1', type: 'hull', name: 'Primary Hull' },
            //     { id: 'hull-2', type: 'hull', name: 'Secondary Hull' },
            //     { id: 'hull-3', type: 'hull', name: 'Connecting Section' }
            // ];

            const hullComponents = [
                { id: 'hull-1', type: 'hull', name: 'Primary Hull', cssClass: 'primary-hull' },
                { id: 'hull-2', type: 'hull', name: 'Secondary Hull', cssClass: 'secondary-hull' },
                { id: 'hull-3', type: 'hull', name: 'Connecting Section', cssClass: 'connecting-hull' }
            ];

            // Initialize availableComponents with hull components
            const availableComponents = [...hullComponents];

            // Add components for existing rooms
            gameState.nodes.forEach(node => {
                const room = roomTypes.find(r => r.id === node.type);
                if (room && room.type) {
                    availableComponents.push({
                        id: node.id,
                        type: room.type,
                        name: node.name
                    });
                }
            });

            // Render available components
            availableComponents.forEach(component => {
                const compStyle = componentStyles[component.type];
                if (!compStyle) return;

                const componentEl = document.createElement('div');
                componentEl.className = 'ship-component';
                componentEl.dataset.componentId = component.id;
                componentEl.dataset.componentType = component.type;
                componentEl.dataset.category = compStyle.category;

                componentEl.innerHTML = `
            <div class="component-visual ${compStyle.shape}" style="background-color: ${compStyle.color};"></div>
            <div class="component-name">${component.name}</div>
        `;

                // Add drag start event
                componentEl.addEventListener('mousedown', (e) => {
                    startDragComponent(e, component.id, component.type);
                });

                componentsList.appendChild(componentEl);
            });

            // Add styling for shapes
            const style = document.createElement('style');
            style.textContent = `
        .component-visual {
            width: 40px;
            height: 40px;
            margin: 0 auto 5px;
        }
        .component-visual.circle {
            border-radius: 50%;
        }
        .component-visual.rectangle {
            border-radius: 5px;
        }
        .component-visual.trapezoid {
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
        }
        .component-visual.diamond {
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        }
        .component-visual.hexagon {
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        }
        .placed-component {
            position: absolute;
            cursor: move;
        }
        .placed-component .component-visual {
            width: 100%;
            height: 100%;
        }
    `;
            document.head.appendChild(style);

            // Restore saved design if any
            if (gameState.shipDesign && gameState.shipDesign.length > 0) {
                gameState.shipDesign.forEach(item => {
                    placeComponent(item.id, item.type, item.x, item.y);
                });
            }

            // Apply category filter
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active state
                    document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Filter components
                    const category = btn.dataset.category;
                    document.querySelectorAll('.ship-component').forEach(comp => {
                        if (category === 'all' || comp.dataset.category === category) {
                            comp.style.display = '';
                        } else {
                            comp.style.display = 'none';
                        }
                    });
                });
            });

            // Auto-arrange button
            document.getElementById('auto-arrange-btn').addEventListener('click', autoArrangeShip);

            // Show the modal
            visualModal.style.display = 'flex';

            // Function to start dragging component
            function startDragComponent(e, id, type) {
                const compStyle = componentStyles[type];
                if (!compStyle) return;

                // Create drag element
                const dragEl = document.createElement('div');
                dragEl.className = 'placed-component dragging';
                dragEl.dataset.componentId = id;
                dragEl.dataset.componentType = type;

                // Set dimensions based on component type
                dragEl.style.width = `${compStyle.width}px`;
                dragEl.style.height = `${compStyle.height}px`;

                // Find the component in availableComponents
                const component = availableComponents.find(c => c.id === id);

                // Create visual
                // dragEl.innerHTML = `<div class="component-visual ${compStyle.shape}" style="background-color: ${compStyle.color};"></div>`;
                // Create visual with conditional class
                if (component && component.cssClass) {
                    dragEl.innerHTML = `<div class="component-visual ${component.cssClass}"></div>`;
                } else {
                    dragEl.innerHTML = `<div class="component-visual ${compStyle.shape}" style="background-color: ${compStyle.color};"></div>`;
                }

                // Position at mouse
                const canvasRect = shipCanvas.getBoundingClientRect();
                dragEl.style.left = `${e.clientX - canvasRect.left - compStyle.width / 2}px`;
                dragEl.style.top = `${e.clientY - canvasRect.top - compStyle.height / 2}px`;

                shipCanvas.appendChild(dragEl);

                // Setup drag events
                document.addEventListener('mousemove', moveComponent);
                document.addEventListener('mouseup', dropComponent);

                e.preventDefault();

                // In the startDragComponent function, add touch event support:

                // Add touch events
                document.addEventListener('touchmove', moveComponentTouch, { passive: false });
                document.addEventListener('touchend', dropComponentTouch);

                // Add these functions to your code:
                function moveComponentTouch(e) {
                    if (e.touches.length === 0) return;
                    const touch = e.touches[0];
                    const canvasRect = shipCanvas.getBoundingClientRect();
                    dragEl.style.left = `${touch.clientX - canvasRect.left - compStyle.width / 2}px`;
                    dragEl.style.top = `${touch.clientY - canvasRect.top - compStyle.height / 2}px`;
                    e.preventDefault();
                }

                function dropComponentTouch() {
                    document.removeEventListener('touchmove', moveComponentTouch);
                    document.removeEventListener('touchend', dropComponentTouch);

                    const dragEl = document.querySelector('.placed-component.dragging');
                    if (dragEl) {
                        dragEl.classList.remove('dragging');
                        updateShipDesign();
                    }
                }


                // Also add tap-to-rotate for mobile:
                dragEl.addEventListener('touchstart', function (e) {
                    if (e.touches.length !== 1) return;

                    // Store the start time for detecting double tap
                    const now = Date.now();
                    const doubleTapDelay = 300; // ms

                    if (dragEl.lastTap && (now - dragEl.lastTap) < doubleTapDelay) {
                        // Double-tap detected, rotate the component
                        const currentRotation = dragEl.dataset.rotation || 0;
                        const newRotation = (parseInt(currentRotation) + 45) % 360;
                        dragEl.style.transform = `rotate(${newRotation}deg)`;
                        dragEl.dataset.rotation = newRotation;
                        updateShipDesign();
                        e.preventDefault();
                    }
                    dragEl.lastTap = now;
                });

                // Functions for dragging
                function moveComponent(e) {
                    const canvasRect = shipCanvas.getBoundingClientRect();
                    dragEl.style.left = `${e.clientX - canvasRect.left - compStyle.width / 2}px`;
                    dragEl.style.top = `${e.clientY - canvasRect.top - compStyle.height / 2}px`;
                }

                function dropComponent(e) {
                    document.removeEventListener('mousemove', moveComponent);
                    document.removeEventListener('mouseup', dropComponent);

                    dragEl.classList.remove('dragging');

                    // Save to design
                    updateShipDesign();
                }
            }

            // Place a component at specific coordinates
            function placeComponent(id, type, x, y) {
                const compStyle = componentStyles[type];
                if (!compStyle) return;

                const component = document.createElement('div');
                component.className = 'placed-component';
                component.dataset.componentId = id;
                component.dataset.componentType = type;

                // Set dimensions based on component type
                component.style.width = `${compStyle.width}px`;
                component.style.height = `${compStyle.height}px`;

                // Position
                component.style.left = `${x}px`;
                component.style.top = `${y}px`;

                const originalComp = availableComponents.find(c => c.id === id);

                // Create visual
                // component.innerHTML = `<div class="component-visual ${compStyle.shape}" style="background-color: ${compStyle.color};"></div>`;
                if (originalComp && originalComp.cssClass) {
                    component.innerHTML = `<div class="component-visual ${originalComp.cssClass}"></div>`;
                } else {
                    component.innerHTML = `<div class="component-visual ${compStyle.shape}" style="background-color: ${compStyle.color};"></div>`;
                }

                                // Add this after creating each component to visually indicate rotation capability
                const rotateHint = document.createElement('div');
                rotateHint.style.position = 'absolute';
                rotateHint.style.top = '0';
                rotateHint.style.left = '0';
                rotateHint.style.padding = '2px';
                rotateHint.style.fontSize = '10px';
                rotateHint.style.backgroundColor = 'rgba(255,255,255,0.5)';
                rotateHint.style.color = 'black';
                rotateHint.textContent = '↻';
                rotateHint.style.pointerEvents = 'none';
                component.appendChild(rotateHint);

                // Make draggable
                component.addEventListener('mousedown', function (e) {
                    if (e.button !== 0) return; // Only left mouse button

                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startLeft = parseInt(component.style.left);
                    const startTop = parseInt(component.style.top);

                    component.classList.add('dragging');

                    function moveHandler(e) {
                        component.style.left = `${startLeft + e.clientX - startX}px`;
                        component.style.top = `${startTop + e.clientY - startY}px`;
                    }

                    function upHandler() {
                        document.removeEventListener('mousemove', moveHandler);
                        document.removeEventListener('mouseup', upHandler);
                        component.classList.remove('dragging');
                        updateShipDesign();
                    }

                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', upHandler);

                    e.preventDefault();
                });


                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                resizeHandle.style.position = 'absolute';
                resizeHandle.style.right = '0';
                resizeHandle.style.bottom = '0';
                resizeHandle.style.width = '10px';
                resizeHandle.style.height = '10px';
                resizeHandle.style.backgroundColor = 'white';
                resizeHandle.style.cursor = 'nwse-resize';
                resizeHandle.style.borderRadius = '50%';
                component.appendChild(resizeHandle);

                // Add resize functionality
                resizeHandle.addEventListener('mousedown', function (e) {
                    e.stopPropagation(); // Prevent dragging

                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startWidth = parseInt(component.style.width);
                    const startHeight = parseInt(component.style.height);

                    function mouseMoveHandler(e) {
                        const newWidth = Math.max(30, startWidth + e.clientX - startX);
                        const newHeight = Math.max(30, startHeight + e.clientY - startY);
                        component.style.width = `${newWidth}px`;
                        component.style.height = `${newHeight}px`;
                        e.preventDefault();
                    }

                    function mouseUpHandler() {
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                        updateShipDesign();
                    }

                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                    e.preventDefault();
                });

                // Also add touch support for resize
                resizeHandle.addEventListener('touchstart', function (e) {
                    e.stopPropagation();

                    const touch = e.touches[0];
                    const startX = touch.clientX;
                    const startY = touch.clientY;
                    const startWidth = parseInt(component.style.width);
                    const startHeight = parseInt(component.style.height);

                    function touchMoveHandler(e) {
                        const touch = e.touches[0];
                        const newWidth = Math.max(30, startWidth + touch.clientX - startX);
                        const newHeight = Math.max(30, startHeight + touch.clientY - startY);
                        component.style.width = `${newWidth}px`;
                        component.style.height = `${newHeight}px`;
                        e.preventDefault();
                    }

                    function touchEndHandler() {
                        document.removeEventListener('touchmove', touchMoveHandler);
                        document.removeEventListener('touchend', touchEndHandler);
                        updateShipDesign();
                    }

                    document.addEventListener('touchmove', touchMoveHandler, { passive: false });
                    document.addEventListener('touchend', touchEndHandler);
                    e.preventDefault();
                });

                // Double click to rotate
//                 component.addEventListener('dblclick', function() {
//     const currentRotation = this.dataset.rotation || 0;
//     const newRotation = (parseInt(currentRotation) + 45) % 360;
//     this.style.transform = `rotate(${newRotation}deg)`;
//     this.dataset.rotation = newRotation;
//     console.log(`Rotated to ${newRotation} degrees`); // Add logging
//     updateShipDesign();
// });

component.addEventListener('dblclick', function() {
    const currentRotation = this.dataset.rotation || 0;
    const newRotation = (parseInt(currentRotation) + 45) % 360;
    this.style.transform = `rotate(${newRotation}deg)`;
    this.dataset.rotation = newRotation;
    console.log(`Rotated to ${newRotation} degrees`); // Add logging
    updateShipDesign();
});

                // Touch rotation for mobile devices
component.addEventListener('touchstart', function(e) {
    if (e.touches.length !== 1) return;
    
    // Store the start time for detecting double tap
    const now = Date.now();
    const doubleTapDelay = 300; // ms
    
    if (this.lastTap && (now - this.lastTap) < doubleTapDelay) {
        // Double-tap detected, rotate the component
        const currentRotation = this.dataset.rotation || 0;
        const newRotation = (parseInt(currentRotation) + 45) % 360;
        this.style.transform = `rotate(${newRotation}deg)`;
        this.dataset.rotation = newRotation;
        updateShipDesign();
        e.preventDefault();
    }
    this.lastTap = now;
});

                shipCanvas.appendChild(component);
            }

            // Update design data
            function updateShipDesign() {
                const components = document.querySelectorAll('.placed-component');
                gameState.shipDesign = [];

                components.forEach(comp => {
                    gameState.shipDesign.push({
                        id: comp.dataset.componentId,
                        type: comp.dataset.componentType,
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top),
                        rotation: parseInt(comp.dataset.rotation || 0)
                    });
                });
            }

            // Auto-arrange ship components
            function autoArrangeShip() {
                // Clear existing layout
                shipCanvas.querySelectorAll('.placed-component').forEach(comp => comp.remove());

                const canvasWidth = shipCanvas.clientWidth;
                const canvasHeight = shipCanvas.clientHeight;
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;

                // Group components by type
                const hullComponents = availableComponents.filter(c => c.type === 'hull');
                const commandComponents = availableComponents.filter(c => c.type === 'command');
                const engineComponents = availableComponents.filter(c => c.type === 'engines');
                const powerComponents = availableComponents.filter(c => c.type === 'power');
                const tacticalComponents = availableComponents.filter(c => c.type === 'tactical');

                // Place hull in center
                if (hullComponents.length > 0) {
                    placeComponent(hullComponents[0].id, 'hull', centerX - 75, centerY - 40);

                    if (hullComponents.length > 1) {
                        placeComponent(hullComponents[1].id, 'hull', centerX - 75, centerY + 60);
                    }
                }

                // Place command at top
                if (commandComponents.length > 0) {
                    placeComponent(commandComponents[0].id, 'command', centerX - 50, centerY - 120);
                }

                // Place engines at bottom
                engineComponents.forEach((comp, i) => {
                    const offset = (i - (engineComponents.length - 1) / 2) * 140;
                    placeComponent(comp.id, 'engines', centerX - 60 + offset, centerY + 150);
                });

                // Place power on sides
                powerComponents.forEach((comp, i) => {
                    const side = i % 2 === 0 ? -1 : 1;
                    const tier = Math.floor(i / 2);
                    placeComponent(comp.id, 'power', centerX + side * 150, centerY - 50 + tier * 100);
                });

                // Place tactical systems
                tacticalComponents.forEach((comp, i) => {
                    const angle = (i / tacticalComponents.length) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * 200 - 35;
                    const y = centerY + Math.sin(angle) * 150 - 35;
                    placeComponent(comp.id, 'tactical', x, y);
                });

                // Update design
                updateShipDesign();
            }
        }

        // Show ship animation during jobs
        function showShipAnimation() {
            // Create modal for animation
            const animationModal = document.createElement('div');
            animationModal.className = 'modal';
            animationModal.id = 'animation-modal';
            animationModal.style.display = 'flex';

            // Create content
            const content = document.createElement('div');
            content.className = 'modal-content';
            content.style.width = '90%';
            content.style.maxWidth = '800px';
            content.style.height = '400px';
            content.style.padding = '0';
            content.style.overflow = 'hidden';
            content.style.backgroundColor = 'black';
            content.style.borderRadius = '10px';
            content.style.position = 'relative';

            // Create starfield background with CSS
            const starfield = document.createElement('div');
            starfield.style.width = '100%';
            starfield.style.height = '100%';
            starfield.style.position = 'absolute';
            starfield.style.background = 'radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px), radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px), radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px), radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px)';
            starfield.style.backgroundSize = '550px 550px, 350px 350px, 250px 250px, 150px 150px';
            starfield.style.backgroundPosition = '0 0, 40px 60px, 130px 270px, 70px 100px';
            starfield.style.animation = 'flying 20s linear infinite';

            // Add animation style
            const animStyle = document.createElement('style');
            animStyle.textContent = `
        @keyframes flying {
            0% { background-position: 0 0, 40px 60px, 130px 270px, 70px 100px; }
            100% { background-position: 1000px 0, 1040px 60px, 1130px 270px, 1070px 100px; }
        }
    `;
            document.head.appendChild(animStyle);

            // Create ship container
            const shipContainer = document.createElement('div');
            shipContainer.style.position = 'absolute';
            shipContainer.style.left = '50%';
            shipContainer.style.top = '50%';
            shipContainer.style.transform = 'translate(-50%, -50%)';
            shipContainer.style.width = '300px';
            shipContainer.style.height = '150px';

            // Create ship based on design
            if (gameState.shipDesign && gameState.shipDesign.length > 0) {
                // Define component styles by type
                const componentStyles = {
                    'power': { color: '#f1c40f', shape: 'power-core' },
                    'engines': { color: '#e67e22', shape: 'engines' },
                    'command': { color: '#3498db', shape: 'trapezoid' },
                    'tactical': { color: '#9b59b6', shape: 'diamond' },
                    'utility': { color: '#1abc9c', shape: 'hexagon' },
                    'hull': { color: '#95a5a6', shape: 'rectangle' }
                };

                // Create each component but scaled down
                gameState.shipDesign.forEach(comp => {
                    const style = componentStyles[comp.type];
                    if (!style) return;

                    const element = document.createElement('div');
                    element.style.position = 'absolute';
                    element.style.left = `${comp.x * 0.4}px`;
                    element.style.top = `${comp.y * 0.4}px`;
                    element.style.width = '30px';
                    element.style.height = '30px';

                    if (comp.type === 'engines') {
                        element.style.width = '40px';
                        element.style.height = '20px';
                    } else if (comp.type === 'hull') {
                        element.style.width = '60px';
                        element.style.height = '30px';
                    }

                    const visual = document.createElement('div');
                    visual.className = `component-visual ${style.shape}`;
                    visual.style.backgroundColor = style.color;
                    visual.style.width = '100%';
                    visual.style.height = '100%';

                    // Apply rotation if any
                    if (comp.rotation) {
                        element.style.transform = `rotate(${comp.rotation}deg)`;
                    }

                    element.appendChild(visual);
                    shipContainer.appendChild(element);
                });
            } else {
                // Default ship shape if no design
                const defaultShip = document.createElement('div');
                defaultShip.style.width = '100%';
                defaultShip.style.height = '100%';
                defaultShip.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%)';
                defaultShip.style.clipPath = 'polygon(0% 50%, 30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%)';

                shipContainer.appendChild(defaultShip);
            }

            // Add elements to DOM
            content.appendChild(starfield);
            content.appendChild(shipContainer);
            animationModal.appendChild(content);
            document.body.appendChild(animationModal);

            // Add close button after delay
            setTimeout(() => {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'btn';
                closeBtn.style.position = 'absolute';
                closeBtn.style.bottom = '10px';
                closeBtn.style.right = '10px';
                closeBtn.textContent = 'Continue';

                closeBtn.addEventListener('click', () => {
                    animationModal.remove();
                });

                content.appendChild(closeBtn);
            }, 3000);

            // Auto close after 10 seconds
            setTimeout(() => {
                if (document.body.contains(animationModal)) {
                    animationModal.remove();
                }
            }, 10000);
        }

        // // Override runJobs to show animation
        // const originalRunJobs = runJobs;
        // runJobs = function() {
        //     showShipAnimation();

        //     // Call original after animation delay
        //     setTimeout(() => {
        //         originalRunJobs();
        //     }, 3000);
        // };

        // Set up all event listeners
        function setupEventListeners() {
            // Grid events
            gridElement.addEventListener('mousedown', handleGridMouseDown);
            gridElement.addEventListener('touchstart', handleGridTouchStart, { passive: false });


            gridElement.addEventListener('touchstart', handlePinchStart, { passive: false });
            gridElement.addEventListener('touchmove', handlePinchMove, { passive: false });


            // Zoom controls
            zoomInBtn.addEventListener('click', () => zoomGrid(1.2));
            zoomOutBtn.addEventListener('click', () => zoomGrid(0.8));
            resetViewBtn.addEventListener('click', centerGridView);

            // Add sidebar toggle for mobile
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const sidebar = document.querySelector('.sidebar');

            if (sidebarToggle && sidebar) {
                sidebarToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('collapsed');
                    sidebarToggle.classList.toggle('collapsed');
                });

                // Default to collapsed sidebar on mobile
                if (window.innerWidth <= 768) {
                    sidebar.classList.add('collapsed');
                    sidebarToggle.classList.add('collapsed');
                }
            }

            // Mode buttons
            deleteBtn.addEventListener('click', () => {
                gameState.deleteMode = !gameState.deleteMode;
                gameState.connectMode = false;
                gameState.selectedRoomType = null;

                deleteBtn.style.backgroundColor = gameState.deleteMode ? 'var(--danger-color)' : '';
                connectBtn.style.backgroundColor = '';

                document.querySelectorAll('.room-item').forEach(el => {
                    el.style.backgroundColor = '';
                });

                if (gameState.deleteMode) {
                    showNotification('Delete Mode', 'Click on rooms to delete them. Click the delete button again to exit this mode.');
                }
            });

            connectBtn.addEventListener('click', () => {
                gameState.connectMode = !gameState.connectMode;
                gameState.deleteMode = false;
                gameState.selectedRoomType = null;

                connectBtn.style.backgroundColor = gameState.connectMode ? 'var(--highlight-color)' : '';
                deleteBtn.style.backgroundColor = '';

                document.querySelectorAll('.room-item').forEach(el => {
                    el.style.backgroundColor = '';
                });

                if (gameState.connectMode) {
                    showNotification('Connect Mode', 'Click on a source room, then a target room to create a connection. Click the connect button again to exit this mode.');
                }
            });

            // Search and filter events
            searchBox.addEventListener('input', (e) => {
                gameState.searchTerm = e.target.value;
                renderRoomList();
            });

            universeFilter.addEventListener('click', (e) => {
                if (e.target.classList.contains('universe-btn')) {
                    document.querySelectorAll('.universe-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    e.target.classList.add('active');
                    gameState.universeFilter = e.target.dataset.universe;
                    renderRoomList();
                }
            });

            // Room type filter events
            document.getElementById('room-type-filter').addEventListener('click', (e) => {
                if (e.target.classList.contains('type-btn')) {
                    document.querySelectorAll('.type-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    e.target.classList.add('active');
                    gameState.roomTypeFilter = e.target.dataset.type;
                    renderRoomList();
                }
            });

            // Modal events
            closeStatusBtn.addEventListener('click', () => {
                statusModal.style.display = 'none';
            });

            // Diagnostics button
            document.getElementById('diagnostics-btn').addEventListener('click', showDiagnostics);

            // Repair button
            document.getElementById('repair-btn').addEventListener('click', showRepairConfirmation);

            // Repair confirmation buttons
            document.getElementById('confirm-repair').addEventListener('click', repairShip);
            document.getElementById('cancel-repair').addEventListener('click', () => {
                document.getElementById('repair-modal').style.display = 'none';
            });

            // Repair modal close button
            document.querySelector('#repair-modal .close-btn').addEventListener('click', () => {
                document.getElementById('repair-modal').style.display = 'none';
            });

            document.querySelector('#status-modal .close-btn').addEventListener('click', () => {
                statusModal.style.display = 'none';
            });

            document.querySelector('#close-connections').addEventListener('click', () => {
                document.getElementById('connections-modal').style.display = 'none';
            });

            document.querySelector('#connections-modal .close-btn').addEventListener('click', () => {
                document.getElementById('connections-modal').style.display = 'none';
            });

            // Notification close button
            document.querySelector('.notification-close').addEventListener('click', () => {
                document.getElementById('notification-modal').classList.remove('show');
            });

            // Run jobs button
            document.getElementById('run-job-btn').addEventListener('click', runJobs);

            // Ship name input
            document.getElementById('ship-name').addEventListener('change', (e) => {
                gameState.shipName = e.target.value || 'Unnamed Ship';
            });

            // Save/Export ship button
            document.getElementById('save-ship-btn').addEventListener('click', () => {
                document.getElementById('export-ship-name').textContent =
                    document.getElementById('ship-name').value.trim() || 'Unnamed Ship';
                document.getElementById('save-modal').style.display = 'flex';
                document.getElementById('qr-container').style.display = 'none';
            });

            // JSON export button
            document.getElementById('export-json-btn').addEventListener('click', exportAsJSON);

            // QR code export button
            document.getElementById('export-qr-btn').addEventListener('click', generateQRCode);

            // Download QR code button
            document.getElementById('download-qr-btn').addEventListener('click', downloadQRCode);

            // Load/Import ship button
            document.getElementById('load-ship-btn').addEventListener('click', () => {
                document.getElementById('load-modal').style.display = 'flex';
                document.getElementById('scanner-container').style.display = 'none';
            });

            // Import file button
            document.getElementById('import-file-btn').addEventListener('click', importFromFile);

            // Scan QR button
            document.getElementById('scan-qr-btn').addEventListener('click', startQRScanner);

            // Modal close buttons
            document.querySelector('#save-modal .close-btn').addEventListener('click', () => {
                document.getElementById('save-modal').style.display = 'none';
            });

            document.querySelector('#load-modal .close-btn').addEventListener('click', () => {
                document.getElementById('load-modal').style.display = 'none';
                stopQRScanner();
            });

            document.getElementById('visualize-btn').addEventListener('click', initShipVisualization);

            // Close button for visualization modal
            document.querySelector('#visual-ship-modal .close-btn').addEventListener('click', () => {
                document.getElementById('visual-ship-modal').style.display = 'none';
            });

            document.addEventListener('keydown', (e) => {
                // Only process shortcuts if no input field is active
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    if (e.key === 's' || e.key === 'S') {
                        showShipStatus();
                    }
                    // Other shortcuts can go here
                }
            });

            // Add header click event to show status
            document.querySelector('header h1').addEventListener('click', showShipStatus);
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>

</html>